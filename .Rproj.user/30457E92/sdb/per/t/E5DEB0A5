{
    "collab_server" : "",
    "contents" : "#' Determines Prior ESS for fixed values of sigma_alpha^2 and sigmabeta^2\n#'\n#'Uses the prior means for the intercept and slope parameters and the number of doses to obtain an approximate prior ESS for the given prior variances. The user should calibrate varint and varbeta with varint>varbeta such that the ESS value is 1.\n#' @param Dose Vector containing standardized doses.\n#' @param meanmu Prior mean for baseline intercept.\n#' @param meanslope Prior mean for baseline slope.\n#' @param MeanInts Vector of prior means for the group specific intercept parameters.\n#' @param MeanSlopes Vector of prior means for the group specific slope parameters.\n#' @param varint Prior variance for the intercept parameters.\n#' @param varbeta Prior variance for the slope parameters.\n#' @return Returns the nonlinear regression model whos parameter estimates will be used as prior means for the SubTITE Design.\n#' @references\n#' [1] Chapple and Thall (2017), Subgroup-specific dose finding in phase I clinical trials based on time to toxicity allowing adaptive subgroup combination.\n#' @examples\n#' ###Specify the prior hypermeans\n#' meanmu=-.5\n#' meanslope=-.05\n#' MeanInts = c(-.5,-.1)\n#' MeanSlopes = c(.1,0)\n#' Dose=sort(rnorm(5))\n#' varint=5\n#' varbeta=1\n#' GetESS(Dose,meanmu,meanslope,MeanInts,MeanSlopes,varint,varbeta)\n#' @export\nGetESS=function(Dose,meanmu,meanslope,MeanInts,MeanSlopes,varint,varbeta){\n\n  prob1=.9\n\n  nDose=length(Dose)\n\n  varint1=varint\n  varbeta1=varbeta\n\n  estBetaParams <- function(mu, var) {\n    alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2\n    beta <- alpha * (1 / mu - 1)\n    return(mu+beta)\n  }\n\n\n  if(length(MeanInts)==1){\n  GROUP=as.list(c(0,0))\n  B=100000\n  PROBS1 = matrix(rep(NA,B*nDose),nrow=B)\n  PROBS2 = matrix(rep(NA,B*nDose),nrow=B)\n\n\n  for(b in 1:B){\n\n    slope=meanslope + rnorm(1,0,sqrt(varbeta))\n    mu=meanmu + rnorm(1,0,sqrt(varint))\n\n\n    Ints=MeanInts + rnorm(1,0,sqrt(varint1))\n\n    Slopes=MeanSlopes + rnorm(1,0,sqrt(varbeta1))\n\n\n\n    I1=rbinom(1,1,prob1)\n    PROBS1[b,]=exp(exp(slope)*Dose+mu)\n\n    PROBS2[b,]=exp(exp(slope+Slopes*I1)*Dose+mu+Ints*I1)\n\n\n  }\n\n  PROBS1=PROBS1/(1+PROBS1)\n\n  PROBS2=PROBS2/(1+PROBS2)\n\n  GROUP[[1]]=PROBS1\n\n  GROUP[[2]]=PROBS2\n\n\n\n  a=estBetaParams(colMeans(GROUP[[1]],na.rm=TRUE),apply(GROUP[[1]],2,var,na.rm=TRUE))\n\n  b=estBetaParams(colMeans(GROUP[[2]],na.rm=TRUE),apply(GROUP[[2]],2,var,na.rm=TRUE))\n\n\n\n\n  return(mean((a+b)/2));\n\n  }\n\n\n\n  if(length(MeanInts)==2){\n    GROUP=as.list(c(0,0,0))\n    B=100000\n    PROBS1 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS2 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS3=PROBS1\n\n    for(b in 1:B){\n\n      slope=meanslope + rnorm(1,0,sqrt(varbeta))\n      mu=meanmu + rnorm(1,0,sqrt(varint))\n\n\n      Ints=MeanInts + rnorm(length(MeanInts),0,sqrt(varint1))\n\n      Slopes=MeanSlopes + rnorm(length(MeanInts),0,sqrt(varbeta1))\n\n\n\n      I1=rbinom(1,1,prob1)\n      PROBS1[b,]=exp(exp(slope)*Dose+mu)\n\n      PROBS2[b,]=exp(exp(slope+Slopes[1]*I1)*Dose+mu+Ints[1]*I1)\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS3[b,]=exp(exp(slope+Slopes[2]*I1)*Dose+mu+Ints[2]*I1)\n\n\n\n    }\n\n    PROBS1=PROBS1/(1+PROBS1)\n\n    PROBS2=PROBS2/(1+PROBS2)\n\n    PROBS3=PROBS3/(1+PROBS3)\n\n    GROUP[[1]]=PROBS1\n\n    GROUP[[2]]=PROBS2\n\n    GROUP[[3]]=PROBS3\n\n\n    a=estBetaParams(colMeans(GROUP[[1]],na.rm=TRUE),apply(GROUP[[1]],2,var,na.rm=TRUE))\n\n    b=estBetaParams(colMeans(GROUP[[2]],na.rm=TRUE),apply(GROUP[[2]],2,var,na.rm=TRUE))\n\n\n    c=estBetaParams(colMeans(GROUP[[3]],na.rm=TRUE),apply(GROUP[[3]],2,var,na.rm=TRUE))\n\n\n\n\n\n    return(mean((a+b+c)/3));\n\n  }\n\n\n\n\n\n  if(length(MeanInts)==3){\n    GROUP=as.list(c(0,0,0,0))\n    B=100000\n    PROBS1 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS2 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS3=PROBS1\n    PROBS4=PROBS3\n\n    for(b in 1:B){\n\n      slope=meanslope + rnorm(1,0,sqrt(varbeta))\n      mu=meanmu + rnorm(1,0,sqrt(varint))\n\n\n      Ints=MeanInts + rnorm(length(MeanInts),0,sqrt(varint1))\n\n      Slopes=MeanSlopes + rnorm(length(MeanInts),0,sqrt(varbeta1))\n\n\n\n      I1=rbinom(1,1,prob1)\n      PROBS1[b,]=exp(exp(slope)*Dose+mu)\n\n      PROBS2[b,]=exp(exp(slope+Slopes[1]*I1)*Dose+mu+Ints[1]*I1)\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS3[b,]=exp(exp(slope+Slopes[2]*I1)*Dose+mu+Ints[2]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS4[b,]=exp(exp(slope+Slopes[3]*I1)*Dose+mu+Ints[3]*I1)\n\n\n    }\n\n    PROBS1=PROBS1/(1+PROBS1)\n\n    PROBS2=PROBS2/(1+PROBS2)\n\n    PROBS3=PROBS3/(1+PROBS3)\n\n\n    PROBS4=PROBS4/(1+PROBS4)\n\n\n    GROUP[[1]]=PROBS1\n\n    GROUP[[2]]=PROBS2\n\n    GROUP[[3]]=PROBS3\n\n    GROUP[[4]]=PROBS4\n\n\n    a=estBetaParams(colMeans(GROUP[[1]],na.rm=TRUE),apply(GROUP[[1]],2,var,na.rm=TRUE))\n\n    b=estBetaParams(colMeans(GROUP[[2]],na.rm=TRUE),apply(GROUP[[2]],2,var,na.rm=TRUE))\n\n\n    c=estBetaParams(colMeans(GROUP[[3]],na.rm=TRUE),apply(GROUP[[3]],2,var,na.rm=TRUE))\n\n\n    d=estBetaParams(colMeans(GROUP[[4]],na.rm=TRUE),apply(GROUP[[4]],2,var,na.rm=TRUE))\n\n\n\n    return(mean((a+b+c+d)/4));\n\n  }\n\n\n\n\n\n  if(length(MeanInts)==4){\n    GROUP=as.list(c(0,0,0,0,0))\n    B=100000\n    PROBS1 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS2 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS3=PROBS1\n    PROBS4=PROBS3\n    PROBS5=PROBS3\n\n\n    for(b in 1:B){\n\n      slope=meanslope + rnorm(1,0,sqrt(varbeta))\n      mu=meanmu + rnorm(1,0,sqrt(varint))\n\n\n      Ints=MeanInts + rnorm(length(MeanInts),0,sqrt(varint1))\n\n      Slopes=MeanSlopes + rnorm(length(MeanInts),0,sqrt(varbeta1))\n\n\n\n      I1=rbinom(1,1,prob1)\n      PROBS1[b,]=exp(exp(slope)*Dose+mu)\n\n      PROBS2[b,]=exp(exp(slope+Slopes[1]*I1)*Dose+mu+Ints[1]*I1)\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS3[b,]=exp(exp(slope+Slopes[2]*I1)*Dose+mu+Ints[2]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS4[b,]=exp(exp(slope+Slopes[3]*I1)*Dose+mu+Ints[3]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS5[b,]=exp(exp(slope+Slopes[4]*I1)*Dose+mu+Ints[4]*I1)\n\n\n    }\n\n    PROBS1=PROBS1/(1+PROBS1)\n\n    PROBS2=PROBS2/(1+PROBS2)\n\n    PROBS3=PROBS3/(1+PROBS3)\n\n\n    PROBS4=PROBS4/(1+PROBS4)\n\n    PROBS5=PROBS5/(1+PROBS5)\n\n\n\n    GROUP[[1]]=PROBS1\n\n    GROUP[[2]]=PROBS2\n\n    GROUP[[3]]=PROBS3\n\n    GROUP[[4]]=PROBS4\n\n    GROUP[[5]]=PROBS5\n\n\n    a=estBetaParams(colMeans(GROUP[[1]],na.rm=TRUE),apply(GROUP[[1]],2,var,na.rm=TRUE))\n\n    b=estBetaParams(colMeans(GROUP[[2]],na.rm=TRUE),apply(GROUP[[2]],2,var,na.rm=TRUE))\n\n\n    c=estBetaParams(colMeans(GROUP[[3]],na.rm=TRUE),apply(GROUP[[3]],2,var,na.rm=TRUE))\n\n\n    d=estBetaParams(colMeans(GROUP[[4]],na.rm=TRUE),apply(GROUP[[4]],2,var,na.rm=TRUE))\n\n    e=estBetaParams(colMeans(GROUP[[5]],na.rm=TRUE),apply(GROUP[[5]],2,var,na.rm=TRUE))\n\n\n    return(mean((a+b+c+d+e)/5));\n\n  }\n\n\n\n\n\n\n  if(length(MeanInts)==4){\n    GROUP=as.list(c(0,0,0,0,0))\n    B=100000\n    PROBS1 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS2 = matrix(rep(NA,B*nDose),nrow=B)\n    PROBS3=PROBS1\n    PROBS4=PROBS3\n    PROBS5=PROBS3\n    PROBS6=PROBS3\n\n\n    for(b in 1:B){\n\n      slope=meanslope + rnorm(1,0,sqrt(varbeta))\n      mu=meanmu + rnorm(1,0,sqrt(varint))\n\n\n      Ints=MeanInts + rnorm(length(MeanInts),0,sqrt(varint1))\n\n      Slopes=MeanSlopes + rnorm(length(MeanInts),0,sqrt(varbeta1))\n\n\n\n      I1=rbinom(1,1,prob1)\n      PROBS1[b,]=exp(exp(slope)*Dose+mu)\n\n      PROBS2[b,]=exp(exp(slope+Slopes[1]*I1)*Dose+mu+Ints[1]*I1)\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS3[b,]=exp(exp(slope+Slopes[2]*I1)*Dose+mu+Ints[2]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS4[b,]=exp(exp(slope+Slopes[3]*I1)*Dose+mu+Ints[3]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS5[b,]=exp(exp(slope+Slopes[4]*I1)*Dose+mu+Ints[4]*I1)\n\n\n      I1=rbinom(1,1,prob1)\n\n      PROBS6[b,]=exp(exp(slope+Slopes[5]*I1)*Dose+mu+Ints[5]*I1)\n\n\n    }\n\n    PROBS1=PROBS1/(1+PROBS1)\n\n    PROBS2=PROBS2/(1+PROBS2)\n\n    PROBS3=PROBS3/(1+PROBS3)\n\n\n    PROBS4=PROBS4/(1+PROBS4)\n\n    PROBS5=PROBS5/(1+PROBS5)\n\n\n\n    PROBS6=PROBS6/(1+PROBS6)\n\n\n    GROUP[[1]]=PROBS1\n\n    GROUP[[2]]=PROBS2\n\n    GROUP[[3]]=PROBS3\n\n    GROUP[[4]]=PROBS4\n\n    GROUP[[5]]=PROBS5\n\n    GROUP[[6]]=PROBS6\n\n\n\n    a=estBetaParams(colMeans(GROUP[[1]],na.rm=TRUE),apply(GROUP[[1]],2,var,na.rm=TRUE))\n\n    b=estBetaParams(colMeans(GROUP[[2]],na.rm=TRUE),apply(GROUP[[2]],2,var,na.rm=TRUE))\n\n\n    c=estBetaParams(colMeans(GROUP[[3]],na.rm=TRUE),apply(GROUP[[3]],2,var,na.rm=TRUE))\n\n\n    d=estBetaParams(colMeans(GROUP[[4]],na.rm=TRUE),apply(GROUP[[4]],2,var,na.rm=TRUE))\n\n    e=estBetaParams(colMeans(GROUP[[5]],na.rm=TRUE),apply(GROUP[[5]],2,var,na.rm=TRUE))\n\n    f=estBetaParams(colMeans(GROUP[[6]],na.rm=TRUE),apply(GROUP[[6]],2,var,na.rm=TRUE))\n\n\n    return(mean((a+b+c+d+e+f)/5));\n\n  }\n\n\nif(length(MeanInts)>4){\n  cat(\"Code only supports up to 6 subgroups, contact maintainer if you desire more\")\n\n}\n\n\n\n}\n\n",
    "created" : 1508358917240.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1797821389",
    "id" : "E5DEB0A5",
    "lastKnownWriteTime" : 1508375531,
    "last_content_update" : 1508375531100,
    "path" : "D:/Users/Andrew/Desktop/Rice/Dr.Thall/SubTite/R/GETESS.R",
    "project_path" : "R/GETESS.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}