{
    "collab_server" : "",
    "contents" : "#' PiecewiseBayesSelect\n#' @param Y1  Vector Containing  event times (or censoring time due to death/censoring)\n#' @param I1 Vector Containing  event indicators (1 if l event for a patient, 0 otherwise)\n#' @param X Matrix of Patient Covariates, the last inc are left out of the selection procedure\n#' @param hyperparameters  List containing 11 hyperparameters and four starting values. In order they are: psi-the swap rate of the SVSS algorithm.\n#'  c-parameter involved in Sigma matrix for selection. z1a, z1b - beta hyper parameters on probability of inclusion for each of the three hazard functions.\n#'  a1,b1- hyperparameters on sigma_lambda.\n#'   clam1- spatial dependency of baseline hazard (between 0 and 1) for the  hazard function.\n#'    Alpha1 - The parameter for the number of split points in the hazard (must be whole number).\n#'    J1max - Maximum number of split points allowed (must be whole number).\n#'    J1- Starting number of split points.  cl1 -Tuning parameter for log baseline hazard height sampler.\n#' @param beta1start  Starting Values for Beta1\n#' @param B  Number of iterations\n#' @param inc  Number of variables left out of selection\n#' @param Path  Where to save posterior samples\n#' @param burn  percent of posterior sample to burn in (burn*B must be a whole number)\n#'@import graphics\n#'@import stats\n#'@import mvtnorm\n#'@import utils\n#' @examples\n#' ##Randomly Generate Semicompeting Risks Data\n#' ####Generates random patient time, indicator and covariates.\n#' n=100\n#' Y1=runif(n,0,100)\n#' I1=rbinom(n,1,.5)\n#' library(mvtnorm)\n#' X=rmvnorm(n,rep(0,13),diag(13))\n#' ####Read in Hyperparameters\n#' ##Swap Rate\n#' psi=.5\n#' c=20\n#' ###Eta Beta function probabilities\n#' z1a=.4\n#' z1b=1.6\n#' ####Hierarchical lam params\n#' ###Sigma^2 lambda_ hyperparameters\n#' a1=.7\n#' b1=.7\n#' ##Spacing dependence c in [0,1]\n#' clam1=1\n#' #####NumSplit\n#' alpha1=3\n#' J1max=10\n#' ####Split Point Starting Value ###\n#' J1=3\n#' ##Tuning parameter for lambda\n#' cl1=.25\n#' ###Beta Starting Values\n#' beta1start=c(0,0,-1,0,0,0,1,1,1,1,1,-1,-1)\n#' hyper=c(psi,c,z1a,z1b,a1,b1,clam1,alpha1,J1max,J1,cl1)\n#' ###Number of iterations and output location\n#' B=200\n#'Path=tempdir()\n#'inc=2\n#'burn=.4\n#' PiecewiseBayesSelect(Y1,I1,X,hyper,beta1start,B,inc,Path,burn)\n#' @export\nPiecewiseBayesSelect=function(Y1,I1,X,hyperparameters,beta1start,B,inc,Path,burn){\n\n\n\n  if(inc%%1>0){\n    cat(\"inc must be a natural number\")\n  }else{\n\n\n\n\n    ####Hyperparameters##\n    ##Swap Rate\n    psi=hyperparameters[1]\n    ##\n    c=hyperparameters[2]\n    ###Eta Beta function probabilities\n    z1a=hyperparameters[3]\n    z1b=hyperparameters[4]\n\n    ####Hierarchical lam params\n    ###Siglam\n    a1=hyperparameters[5]\n    b1=hyperparameters[6]\n\n    ##Spacing dependence c in [0,1]\n    clam1=hyperparameters[7]\n\n    ##Lamsampler params\n    #####NumSplit\n    alpha1=hyperparameters[8]\n\n    J1max=hyperparameters[9]\n\n    ####Split Points###\n    J1=hyperparameters[10]\n\n\n\n    cl1=hyperparameters[11]\n\n\n\n\n    p1=ncol(X)-inc\n\n    n=length(Y1)\n\n\n\n\n\n\n\n\n\n\n\n    #####In program\n    ###Make Acceptance Matrices\n    ###Beta/Eta###\n    beta1=matrix(rep(1,B*(p1+inc)),nrow=B)\n    eta1=matrix(rep(1,B*p1),nrow=B)\n    ####Frailty Matrix###\n    ###\n    Mulam1=rep(0,B)\n    Siglam1=rep(1,B)\n\n\n\n\n\n\n    ###Make Eta1Start\n    beta1[1,]=beta1start\n\n    ##\n    eta1start=rep(1,p1)\n\n\n    for(i in 1:p1){\n      if(beta1start[i]==0){\n        eta1start[i]=0\n      }\n    }\n\n\n    eta1[1,]=eta1start\n\n\n\n    m1 = max(Y1[I1==1])+.001\n\n\n\n\n    ####Acceptance Matrices\n\n\n    Acceptlam1=matrix(rep(NA,B*(J1max+1)),nrow=B)\n\n    accepts1=rep(0,B)\n\n    Indmix1=rep(0,B)\n\n    sum1=rep(0,B)\n\n    split1=rep(0,B)\n\n\n    Indcond1=matrix(rep(NA,p1*B),nrow=B)\n\n\n\n    #########################S Matrices!!!\n    #Reset up lam and S1 matrices\n    s1=matrix(rep(NA,B*(J1max+2)),nrow=B)\n    s1[1,1:(J1+2)]=sort(seq(0,m1,length.out = J1+2))\n\n    lam1=matrix(rep(NA,B*(J1max+1)),nrow=B)\n\n    lam1[1,1:(J1+1)]=rep(0,J1+1)\n\n    ###Acceptance\n    split1=rep(0,B)\n\n    IndB1=rep(0,B)\n\n    ###Death\n    IndD1=rep(0,B)\n\n    Indeta1=rep(0,B)\n\n    Ind1s=rep(0,B)\n\n\n\n\n\n\n\n\n    n=length(Y1)\n    G1=J1+1\n\n\n\n\n\n\n    #####\n    LK1L=function(Y1,I1,X,Beta1,s1,lam1){\n\n      LOGBH=0\n      et1=X%*%Beta1\n\n\n      for(k in 1:G1){\n\n\n        Del=pmax(0,pmin(Y1,s1[k+1])-s1[k])\n\n\n\n        LOGBH=LOGBH-sum(Del*exp(lam1[k])*exp(et1))\n\n        zu=Y1<=s1[k+1]\n        zl=Y1>s1[k]\n        LOGBH=LOGBH+sum(zu*zl*I1)*lam1[k]\n      }\n\n\n\n      return(LOGBH)\n\n    }\n    ###Haz 2\n\n\n    ###\n\n\n\n    #####\n    LK1=function(Y1,I1,X,Beta1,s1,lam1){\n\n      LOGBH=0\n      et1=X%*%Beta1\n\n\n      for(k in 1:G1){\n\n\n        Del=pmax(0,pmin(Y1,s1[k+1])-s1[k])\n\n\n\n        LOGBH=LOGBH-sum(Del*exp(lam1[k])*exp(et1))\n\n      }\n\n      LOGBH=LOGBH+sum(I1*et1)\n\n\n\n      return(LOGBH)\n\n    }\n    ###Haz 2\n\n\n\n\n\n\n\n    if(inc>1){\n      cat(\"More than One Variable Included\", \"\n\n\n          \")\n\n      ###Set Up Additional Acceptance Matrix\n\n      IncCond1=matrix(rep(0,B*inc),nrow=B)\n\n\n\n      iter=c(0,0)\n\n\n      ##Sampler\n\n\n      for(b in 2:B){\n\n\n\n\n\n        if(b%%10000==0){cat(b, \"iterations\",date(), \"  \")}else{\n          if(b%%5000==0){cat(b, \" iterations \")}}\n\n        U=runif(1,0,1)\n\n\n        iter[1]=\"etabeta1\"\n\n        ###eta1,beta1\n        eta1[b,]=eta1[b-1,]\n        beta1[b,]=beta1[b-1,]\n\n        if(sum(eta1[b-1,])==0|sum(eta1[b-1,])==p1){\n          if(sum(eta1[b-1,])==0){\n            ###Add Automatically\n            iter[2]=\"Add\"\n            Ind=sample(1:p1,1)\n            eta1[b,Ind]=1\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            spotnew=rep(0,length(includednew))\n            for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n            spot2=max(spotnew)\n            ###Make sigma matrices##\n            Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n            ####\n            V1 = Sigmanew[spot2,spot2]\n            V2 = as.matrix(Sigmanew[-spot2,-spot2])\n            V12 = as.matrix(Sigmanew[spot2,-spot2])\n            thetab=beta1[b-1,c(includednew, (p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot2])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            beta1[b,Ind]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n            ######Accept reject###\n\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n\n            alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }\n          }\n          if(sum(eta1[b-1,])==p1){\n            ###Delete Automatically\n            Ind=sample(1:p1,1)\n            iter[2]=\"delete\"\n            eta1[b,Ind]=0\n            beta1[b,Ind]=0\n            includedold=rep(0,p1)\n            for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n            includedold=includedold[includedold != 0]\n            spotold=rep(0,length(includedold))\n            for(k in 1:length(includedold)){if(includedold[k]==Ind){spotold[k]=k}}\n            spot1=max(spotold)\n\n\n            ###Make sigma matrices##\n            Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n\n            ###Old density###\n            V1 = Sigmaold[spot1,spot1]\n            V2 = as.matrix(Sigmaold[-spot1,-spot1])\n            V12 = as.matrix(Sigmaold[spot1,-spot1])\n            thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot1])\n            meanold = t(V12)%*%solve(V2)%*%thetano\n            varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }}\n        }else{\n\n          U=runif(1,0,1)\n\n          if(U<psi){\n            ###Swapper\n            includedold=rep(0,p1)\n            iter[2]=\"swap\"\n            for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n            includedold=includedold[includedold != 0]\n            ones=includedold\n            zeros=rep(0,p1)\n            for(k in 1:p1){if(eta1[b-1,k]==0){zeros[k]=k}}\n            zeros=zeros[zeros != 0]\n            ###Sample swap indices###\n            if(length(ones)==1){\n              Indone=ones}else{\n                Indone=sample(ones,1)}\n            if(length(zeros)==1){Indzero=zeros}else{\n              Indzero=sample(zeros,1)}\n            ####Change Beta/eta\n            eta1[b,Indone]=0\n            eta1[b,Indzero]=1\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            spotold=rep(0,length(includedold))\n            for(k in 1:length(includedold)){if(Indone==includedold[k]){spotold[k]=k}}\n            spot1=max(spotold)\n            spotnew=rep(0,length(includednew))\n            for(k in 1:length(includednew)){if(Indzero==includednew[k]){spotnew[k]=k}}\n            spot2=max(spotnew)\n            ###Make sigma matrices##\n            Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n            Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n            ###Generate new vector##\n            beta1[b,Indone]=0\n\n            ##meannew,varnew##\n            V1 = Sigmanew[spot2,spot2]\n            V2 = as.matrix(Sigmanew[-spot2,-spot2])\n            V12 = as.matrix(Sigmanew[spot2,-spot2])\n            thetab=beta1[b-1,c(includednew,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot2])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            beta1[b,Indzero]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(beta1[b,Indzero],meannew,varnew))\n            ###Old density###\n            V1 = Sigmaold[spot1,spot1]\n            V2 = as.matrix(Sigmaold[-spot1,-spot1])\n            V12 = as.matrix(Sigmaold[spot1,-spot1])\n            thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot1])\n            meanold = t(V12)%*%solve(V2)%*%thetano\n            varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            do=log(dnorm(beta1[b-1,Indone],meanold,varold))\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo+dn-do\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n\n            }\n\n          }else{\n            ###Add/Delete\n            Ind=sample(1:p1,1)\n            if(eta1[b-1,Ind]==1){\n              ##delete##\n              iter[2]=\"delete\"\n              eta1[b,Ind]=0\n              beta1[b,Ind]=0\n              includedold=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n              includedold=includedold[includedold != 0]\n              spotold=rep(0,length(includedold))\n              for(k in 1:length(includedold)){if(Ind==includedold[k]){spotold[k]=k}}\n              spot1=max(spotold)\n\n\n              ###Make sigma matrices##\n              Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n\n              ###Old density###\n              V1 = Sigmaold[spot1,spot1]\n              V2 = as.matrix(Sigmaold[-spot1,-spot1])\n              V12 = as.matrix(Sigmaold[spot1,-spot1])\n              thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n              thetano = as.matrix(thetab[-spot1])\n              meanold = t(V12)%*%solve(V2)%*%thetano\n              varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n              U=log(runif(1,0,1))\n              if(is.finite(alphab1)==FALSE){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n\n              }\n\n            }else{\n              ###Add###\n              eta1[b,Ind]=1\n\n              iter[2]=\"add\"\n              includednew=rep(0,p1)\n              for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n              includednew=includednew[includednew != 0]\n              spotnew=rep(0,length(includednew))\n              for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n              spot2=max(spotnew)\n              ###Make sigma matrices##\n              Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n              ####\n              V1 = Sigmanew[spot2,spot2]\n              V2 = as.matrix(Sigmanew[-spot2,-spot2])\n              V12 = as.matrix(Sigmanew[spot2,-spot2])\n              thetab=beta1[b-1,c(includednew,(p1+1):(p1+inc))]\n              thetano = as.matrix(thetab[-spot2])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              beta1[b,Ind]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n              U=log(runif(1,0,1))\n              if(is.finite(alphab1)==FALSE){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n              }\n\n\n            }\n\n          }}\n\n\n\n        iter[1]=\"Beta1\"\n        iter[2]=\"Included\"\n\n        if(sum(eta1[b,])==0){\n          ##Sample Included\n          Sigmanew= c*solve(t(X[,(p1+1):(p1+inc)])%*%X[,(p1+1):(p1+inc)])\n          zeta1n=beta1[b,(p1+1):(p1+inc)]\n          for(k in 1:inc){\n            zeta1=zeta1n\n            V1 = Sigmanew[k,k]\n            V2 = as.matrix(Sigmanew[-k,-k])\n            V12 = as.matrix(Sigmanew[k,-k])\n            thetano=zeta1[-k]\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            zeta1[k]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(zeta1[k],meannew,varnew))\n            ###density old\n            do=log(dnorm(zeta1n[k],meannew,varnew))\n            beta=beta1[b,]\n            beta[(p1+1):(p1+inc)]=zeta1\n            Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n            alphab1m=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n\n            if(is.finite(alphab1m)==FALSE){\n              IncCond1[b,k]=0\n            }else{\n              if(U>alphab1m){\n                IncCond1[b,k]=0\n              }else{IncCond1[b,k]=1\n              beta1[b,]=beta\n              zeta1n=zeta1\n              }}\n            ##End Inc Sampler\n          } }else{\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            zeta1n=beta1[b,c(includednew,(p1+1):(p1+inc))]\n\n            ###Make sigma matrices##\n            Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n            ####\n            p=length(includednew)+inc\n            ####Update All included variables\n\n            for(k in (length(includednew)+1):(length(includednew)+inc)){\n              zeta1=zeta1n\n              V1 = Sigmanew[k,k]\n              V2 = as.matrix(Sigmanew[-k,-k])\n              V12 = as.matrix(Sigmanew[k,-k])\n              thetano = as.matrix(zeta1[-k])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              zeta1[k]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(zeta1[k],meannew,varnew))\n              ###density old\n              do=log(dnorm(beta1[b,(p1+k-length(includednew))],meannew,varnew))\n\n\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,c(beta1[b,1:p1],zeta1n[(length(zeta1n)-inc+1):length(zeta1n)]), s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,c(beta1[b,1:p1],zeta1[(length(zeta1n)-inc+1):length(zeta1n)]), s1[b-1,],lam1[b-1,])\n\n              alphab1s=Liken-Likeo+dn -do\n              U=log(runif(1,0,1))\n\n              if(is.finite(alphab1s)==FALSE){\n                IncCond1[b,(k-p1)]=0\n\n              }else{\n\n                if(U>alphab1s){\n\n\n\n                  IncCond1[b,(k-p1)]=0\n\n                }else{IncCond1[b,(k-p1)]=1\n                zeta1n=zeta1\n                beta1[b,]=c(beta1[b,1:p1],zeta1[(length(zeta1)-inc+1):length(zeta1)])\n\n                }\n              }\n\n            }\n\n            ###End included sampler###\n          }\n\n\n\n        #####Conditional Sampler for Included!###\n\n\n        if(sum(eta1[b,])>0){\n\n          iter[2]=\"Conditional Inclusion\"\n          ##Jointly Update nonzero betas\n          zeta1=beta1[b,]\n          zeta1=zeta1[zeta1!=0]\n          zeta1n=zeta1\n          Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n\n\n\n          ###############\n          ####\n\n          for(k in 1:length(includednew)){\n\n\n            V1 = Sigmanew[k,k]\n            V2 = as.matrix(Sigmanew[-k,-k])\n            V12 = as.matrix(Sigmanew[k,-k])\n            thetab=beta1[b,c(includednew,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-k])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            zeta1n[k]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(zeta1n[k],meannew,varnew))\n            ###density old\n            do=log(dnorm(zeta1[k],meannew,varnew))\n\n\n\n\n\n\n            beta=beta1[b,]\n            beta[c(includednew,(p1+1):(p1+inc))]=zeta1n\n\n\n            Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n            alphab1m=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1m)==FALSE){\n              Indcond1[b,k]=0\n            }else{\n              if(U>alphab1m){\n                Indcond1[b,includednew[k]]=0\n                zeta1n[k]=zeta1[k]\n              }else{Indcond1[b,includednew[k]]=1\n              beta1[b,]=beta\n              zeta1[k]=zeta1n[k]\n              }}\n\n          }\n\n\n\n          ##Jointly Update nonzero betas\n          iter[2]=\"mixing\"\n          zeta1n=beta1[b,]\n          Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n\n\n          zeta1n[c(includednew,(p1+1):(p1+inc))]=rmvnorm(1,rep(0,length(includednew)+inc),Sigmanew)\n\n          beta=beta1[b,]\n          beta=beta[beta!=0]\n\n          dn=log(dmvnorm(zeta1n[c(includednew,(p1+1):(p1+inc))],rep(0,length(includednew)+inc),Sigmanew))\n          ###density old\n          do=log(dmvnorm(beta,rep(0,length(includednew)+inc),Sigmanew))\n\n          ######Accept reject###\n          Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n          Liken=LK1(Y1,I1,X,zeta1n, s1[b-1,],lam1[b-1,])\n\n          alphamix1=Liken-Likeo+dn -do\n          U=log(runif(1,0,1))\n          if(is.finite(alphamix1)==FALSE){\n            Indmix1[b]=0\n          }else{\n            if(U>alphamix1){\n\n              Indmix1[b]=0\n            }else{Indmix1[b]=1\n            beta1[b,]=zeta1n\n            }}\n\n        }else{\n          ##Jointly Update nonzero betas\n          iter[2]=\"mixing No eta\"\n          zeta1n=beta1[b,]\n          Sigmanew=c*solve(t(X[,(p1+1):(p1+inc)])%*%X[,(p1+1):(p1+inc)])\n\n\n          zeta1n[(p1+1):(p1+inc)]=rmvnorm(1,rep(0,inc),Sigmanew)\n\n          beta=beta1[b,]\n          beta=beta[beta!=0]\n\n          dn=log(dmvnorm(zeta1n[(p1+1):(p1+inc)],rep(0,inc),Sigmanew))\n          ###density old\n          do=log(dmvnorm(beta,rep(0,inc),Sigmanew))\n\n          ######Accept reject###\n          Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n          Liken=LK1(Y1,I1,X,zeta1n,s1[b-1,],lam1[b-1,])\n\n          alphamix1=Liken-Likeo+dn -do\n          U=log(runif(1,0,1))\n\n          if(is.finite(alphamix1)==FALSE){\n            Indmix1[b]=0}else{\n\n              if(U>alphamix1){\n\n\n\n                Indmix1[b]=0\n              }else{Indmix1[b]=1\n              beta1[b,]=zeta1n\n              }}\n\n        }\n\n\n\n        S1=s1[b-1,]\n        S1=S1[!is.na(S1)]\n\n\n        L1=lam1[b-1,]\n        L1=as.matrix(L1[!is.na(L1)])\n\n\n        ############################################\n        #####Start LogBH Samplers###################\n        ############################################\n        ####Lam1####\n\n        iter[1]=\"LogBH1\"\n        iter[2]=\"matrixsetup\"\n\n        W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n        Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n        length1=rep(0,J1+1)\n\n\n\n\n        for(j in 1:length(length1)){\n          length1[j]=s1[b-1,j+1]-s1[b-1,j]\n        }\n\n\n        if(J1<2){\n          if(J1==1){\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n          }else{\n\n            Q1=as.matrix(2/(m1))\n            SigLam1=Q1\n          }\n        }else{\n\n\n          for(j in 2:J1){\n            W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n          }\n\n\n          Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n          Q1[1,1]=2/(2*length1[1]+length1[2])\n          W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n          W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n          SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n        }\n\n\n\n        iter[2]=\"Mu\"\n        ##Lambda1 Hierarchical Sampler\n        ##Mulam\n\n        if(J1>0){\n\n          Mulam1[b]=rnorm(1,(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%L1)/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1))),sqrt(Siglam1[b-1]/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1)))))\n\n\n          Siglam1[b]=1/rgamma(1,a1+(J1+1)/2,b1+.5*(t(as.matrix(rep(Mulam1[b],J1+1))-L1)%*%solve(SigLam1)%*%(as.matrix(rep(Mulam1[b],J1+1))-L1)))\n\n\n          ##Siglam\n\n          iter[2]=\"Sigma\"\n        }else{\n\n\n\n          Mulam1[b]=rnorm(1,lam1[b-1,1],sqrt(Siglam1[b-1]))\n\n\n          Siglam1[b]=1/rgamma(1,a1+1/2,b1+.5*(Mulam1[b]-lam1[b-1,1])^2)\n\n\n\n        }\n\n\n        #lambda1\n        iter[2]=\"lam1\"\n        lam1[b,]=lam1[b-1,]\n        #######\n\n        for(m in 1:(J1+1)){\n\n\n\n          lam=lam1[b,]\n          lam=lam[is.na(lam)==FALSE]\n          lambda=lam\n\n          lam[m]=lambda[m]+runif(1,-cl1,cl1)\n\n\n          if(J1==0){\n            do=log(dnorm(lambda[m],Mulam1[b],sqrt(Siglam1[b])))\n            dn=log(dnorm(lam[m],Mulam1[b],sqrt(Siglam1[b])))\n          }else{\n\n\n            #do=-(t(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n            #dn=-(t(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n\n            do=dmvnorm(lambda,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n            do=dmvnorm(lam,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n          }\n\n          Likeo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n          Liken=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam)\n\n\n\n\n          U=log(runif(1,0,1))\n          alphalam=Liken-Likeo+dn-do\n\n          if(is.nan(alphalam)==TRUE){\n            lam1[b,m]=lam1[b-1,m]\n            Acceptlam1[b,m]=0\n          }else{\n\n            if(U<alphalam){\n              Acceptlam1[b,m]=1\n              lam1[b,m]=lam[m]\n            }else{Acceptlam1[b,m]=0}\n          }\n\n\n        }\n\n\n\n\n        #####################################################\n        ###################################################\n\n        iter[1]=\"Haz1\"\n        iter[2]=\"Birth\"\n\n        ###Random Perturbation###\n        U1=runif(1,0,1)\n        #####\n\n        s=s1[b-1,]\n        s=s[!is.na(s)]\n\n        if(length(s)<J1max){\n          Birth=runif(1,0,m1)\n\n          s1[b,1:(J1+3)]=sort(c(s,Birth))\n\n          for(k in 2:(J1+2)){\n            if(Birth>s1[b-1,k-1] & Birth<s1[b-1,k]){\n              Ind=k-1\n            }\n          }\n\n          lam=rep(0,J1+2)\n\n          if(Ind==1 | Ind==J1+1){\n            if(Ind==1){\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n            }else{\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            }\n          }else{\n            lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n          }\n\n          lam=lam[!is.na(lam)]\n\n          lambda=lam1[b,]\n          lambda=lambda[!is.na(lambda)]\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n\n          if(J1>0){\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n          }else{\n            do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n          }\n\n          prior=((2*J1+3)*(2*J1+2)*(Birth-s1[b-1,Ind])*(s1[b-1,Ind+1]-Birth))/((m1^2)*(s1[b-1,Ind+1]-s1[b-1,Ind]))\n\n          G1=G1+1\n          J1=J1+1\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam)\n\n\n          ##Make SigLam1\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n          }\n\n\n\n          dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),Siglam1[b]*SigLam1n))\n\n\n\n\n          alpha=Ln-Lo+dn-do-log(U1*(1-U1)) + log(prior)\n\n          if(is.nan(alpha)==TRUE){\n            IndB1[b]=0\n            s1[b,]=s1[b-1,]\n            J1=J1-1\n            G1=G1-1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            if(U<alpha){\n              IndB1[b]=1\n              lam1[b,1:(J1+1)]=lam\n            }else{\n              s1[b,]=s1[b-1,]\n              IndB1[b]=0\n              J1=J1-1\n              G1=G1-1\n            }\n\n          }\n\n\n        }else{\n          s1[b,]=s1[b-1,]\n          IndB1[b]=0\n        }\n\n\n        #########################################################\n        ###################Death Sampler#########################\n        ##########################################################\n        iter[2]=\"Death\"\n\n        U1=runif(1,0,1)\n\n        if(J1==0){\n          IndD1[b]=0\n          s1[b,]=s1[b-1,]\n        }else{\n\n          if(J1==1){\n            Ind=2\n          }else{\n\n            Ind=sample(2:(J1+1),1)\n          }\n\n\n          s=s1[b,]\n          s=s[-Ind]\n\n          lam=lam1[b,]\n          lambda=lam[!is.na(lam)]\n\n          lam=lam[!is.na(lam)]\n          lam=lam[-Ind]\n\n          lam[Ind-1]=((s1[b,Ind]-s1[b,Ind-1])*lam1[b,Ind-1]+(s1[b,Ind+1]-s1[b,Ind])*lam1[b,Ind])/(s1[b,Ind+1]-s1[b,Ind-1])\n\n\n\n          #############################################\n          ####Sets up SigLam1 matrix for old density###\n          #############################################\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n              do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n\n\n            }else{\n\n\n              do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n          }\n          #############################################\n          #############################################\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam1[b,])\n\n\n          prior=((m1^2)*(s1[b,Ind+1]-s1[b,Ind-1]))/((2*J1+1)*(2*J1)*(s1[b,Ind]-s1[b,Ind-1])*(s1[b,Ind+1]-s1[b,Ind]))\n\n\n          G1=G1-1\n          J1=J1-1\n\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]), s,lam)\n\n          ###Make siglam matrix\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n\n          length1=rep(0,J1+1)\n\n\n\n\n          for(j in 1:length(length1)){\n            length1[j]=s[j+1]-s[j]\n          }\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n              dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n              dn=log(dpois(J1,alpha1))+log(dnorm(lam,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n            dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n          }\n          ####\n\n\n\n\n          alpha=Ln-Lo+dn-do+log(prior)+log(U1*(1-U1))\n\n          if(is.nan(alpha)==TRUE){\n            IndD1[b]=0\n            J1=J1+1\n            G1=G1+1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            iter[2]=\"AcceptRejDeath\"\n\n            if(U<alpha){\n              s1[b,]=c(s,NA)\n              IndD1[b]=1\n              lam1[b,1:(J1+1)]=lam\n              lam1[b,(J1+2):J1max]=rep(NA,J1max-J1-1)\n            }else{\n              IndD1[b]=0\n              J1=J1+1\n              G1=G1+1\n            }\n          }\n\n          ####End else\n        }\n        ##\n\n\n\n\n\n\n        split1[b]=J1\n\n        ##\n        sum1[b]=sum(eta1[b,])\n\n\n\n      }\n\n\n\n\n\n      ################End Samplers\n      cat(c,z1a,z1b,\"\n\n\n\n\n          \", \"\n\n\n\n          \", \"\n\n\n          \", \"Posterior Inclusion Probabilities after half Burnin\", \"\n\n\n          \", \"Hazard 1\", \"\n\n          \", colMeans(eta1[(B*burn+1):B,])*100, \"\n\n\n          \", \"IndEta\",mean(Indeta1[(B*burn+1):B])*100,\"\n\n\n          \",\"IndMix\",mean(Indmix1[(B*burn+1):B])*100,\"\n\n\n          \", \"Included Acceptance\", \"\n\n          \", \"Haz1\", \"\n          \", colMeans(IncCond1[(B*burn+1):B,])*100, \"\n\n          \", colMeans(Indcond1[(B*burn+1):B,],na.rm=TRUE)*100,\"\n\n\n          \",\"Survival\",\"\n\n          \",\"IndDeath\",mean(IndD1[(B*burn+1):B])*100,\"\n\n          \",\"IndBirth\",mean(IndB1[(B*burn+1):B])*100,\"\n\n          \",\"Lambda\",\"\n\n          \", \"Lam1\",\n          colMeans(Acceptlam1[(B*burn+1):B,],na.rm=TRUE)*100)\n\n\n\n\n\n      Path1= paste0(Path,\"/IncCond1.txt\")\n\n      write.table(IncCond1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n\n\n\n\n    }\n\n\n\n\n    if(inc==1){\n      cat(\"One Variable Included\")\n\n      Ind1s=rep(0,B)\n\n\n      for(b in 2:B){\n\n\n\n        if(b%%10000==0){cat(b, \"iterations\",date(), \"  \")}else{\n          if(b%%5000==0){cat(b, \" iterations \")}}\n\n        U=runif(1,0,1)\n\n\n        iter[1]=\"etabeta1\"\n\n        ###eta1,beta1\n        eta1[b,]=eta1[b-1,]\n        beta1[b,]=beta1[b-1,]\n\n        if(sum(eta1[b-1,])==0|sum(eta1[b-1,])==p1){\n          if(sum(eta1[b-1,])==0){\n            ###Add Automatically\n            iter[2]=\"Add\"\n            Ind=sample(1:p1,1)\n            eta1[b,Ind]=1\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            spotnew=rep(0,length(includednew))\n            for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n            spot2=max(spotnew)\n            ###Make sigma matrices##\n            Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n            ####\n            V1 = Sigmanew[spot2,spot2]\n            V2 = as.matrix(Sigmanew[-spot2,-spot2])\n            V12 = as.matrix(Sigmanew[spot2,-spot2])\n            thetab=beta1[b-1,c(includednew, (p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot2])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            beta1[b,Ind]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n            ######Accept reject###\n\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }\n          }\n          if(sum(eta1[b-1,])==p1){\n            ###Delete Automatically\n            Ind=sample(1:p1,1)\n            iter[2]=\"delete\"\n            eta1[b,Ind]=0\n            beta1[b,Ind]=0\n            includedold=rep(0,p1)\n            for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n            includedold=includedold[includedold != 0]\n            spotold=rep(0,length(includedold))\n            for(k in 1:length(includedold)){if(includedold[k]==Ind){spotold[k]=k}}\n            spot1=max(spotold)\n\n\n            ###Make sigma matrices##\n            Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n\n            ###Old density###\n            V1 = Sigmaold[spot1,spot1]\n            V2 = as.matrix(Sigmaold[-spot1,-spot1])\n            V12 = as.matrix(Sigmaold[spot1,-spot1])\n            thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot1])\n            meanold = t(V12)%*%solve(V2)%*%thetano\n            varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }}\n        }else{\n\n          U=runif(1,0,1)\n\n          if(U<psi){\n            ###Swapper\n            includedold=rep(0,p1)\n            iter[2]=\"swap\"\n            for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n            includedold=includedold[includedold != 0]\n            ones=includedold\n            zeros=rep(0,p1)\n            for(k in 1:p1){if(eta1[b-1,k]==0){zeros[k]=k}}\n            zeros=zeros[zeros != 0]\n            ###Sample swap indices###\n            if(length(ones)==1){\n              Indone=ones}else{\n                Indone=sample(ones,1)}\n            if(length(zeros)==1){Indzero=zeros}else{\n              Indzero=sample(zeros,1)}\n            ####Change Beta/eta\n            eta1[b,Indone]=0\n            eta1[b,Indzero]=1\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            spotold=rep(0,length(includedold))\n            for(k in 1:length(includedold)){if(Indone==includedold[k]){spotold[k]=k}}\n            spot1=max(spotold)\n            spotnew=rep(0,length(includednew))\n            for(k in 1:length(includednew)){if(Indzero==includednew[k]){spotnew[k]=k}}\n            spot2=max(spotnew)\n            ###Make sigma matrices##\n            Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n            Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n            ###Generate new vector##\n            beta1[b,Indone]=0\n\n            ##meannew,varnew##\n            V1 = Sigmanew[spot2,spot2]\n            V2 = as.matrix(Sigmanew[-spot2,-spot2])\n            V12 = as.matrix(Sigmanew[spot2,-spot2])\n            thetab=beta1[b-1,c(includednew,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot2])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            beta1[b,Indzero]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(beta1[b,Indzero],meannew,varnew))\n            ###Old density###\n            V1 = Sigmaold[spot1,spot1]\n            V2 = as.matrix(Sigmaold[-spot1,-spot1])\n            V12 = as.matrix(Sigmaold[spot1,-spot1])\n            thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-spot1])\n            meanold = t(V12)%*%solve(V2)%*%thetano\n            varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            do=log(dnorm(beta1[b-1,Indone],meanold,varold))\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo+dn-do\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1)==FALSE){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n\n            }\n\n          }else{\n            ###Add/Delete\n            Ind=sample(1:p1,1)\n            if(eta1[b-1,Ind]==1){\n              ##delete##\n              iter[2]=\"delete\"\n              eta1[b,Ind]=0\n              beta1[b,Ind]=0\n              includedold=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n              includedold=includedold[includedold != 0]\n              spotold=rep(0,length(includedold))\n              for(k in 1:length(includedold)){if(Ind==includedold[k]){spotold[k]=k}}\n              spot1=max(spotold)\n\n\n              ###Make sigma matrices##\n              Sigmaold=c*solve(t(X[,c(includedold,(p1+1):(p1+inc))])%*%X[,c(includedold,(p1+1):(p1+inc))])\n\n              ###Old density###\n              V1 = Sigmaold[spot1,spot1]\n              V2 = as.matrix(Sigmaold[-spot1,-spot1])\n              V12 = as.matrix(Sigmaold[spot1,-spot1])\n              thetab=beta1[b-1,c(includedold,(p1+1):(p1+inc))]\n              thetano = as.matrix(thetab[-spot1])\n              meanold = t(V12)%*%solve(V2)%*%thetano\n              varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n              U=log(runif(1,0,1))\n              if(is.finite(alphab1)==FALSE){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n\n              }\n\n            }else{\n              ###Add###\n              eta1[b,Ind]=1\n\n              iter[2]=\"add\"\n              includednew=rep(0,p1)\n              for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n              includednew=includednew[includednew != 0]\n              spotnew=rep(0,length(includednew))\n              for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n              spot2=max(spotnew)\n              ###Make sigma matrices##\n              Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n              ####\n              V1 = Sigmanew[spot2,spot2]\n              V2 = as.matrix(Sigmanew[-spot2,-spot2])\n              V12 = as.matrix(Sigmanew[spot2,-spot2])\n              thetab=beta1[b-1,c(includednew,(p1+1):(p1+inc))]\n              thetano = as.matrix(thetab[-spot2])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              beta1[b,Ind]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n              U=log(runif(1,0,1))\n              if(is.finite(alphab1)==FALSE){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n              }\n\n\n            }\n\n          }}\n\n\n\n\n\n        ###End SVSS\n\n\n        ###INCLUDED SAMPLERS\n\n        iter[1]=\"Beta1\"\n        iter[2]=\"Included\"\n\n        if(sum(eta1[b,])==0){\n          ##Sample Included\n          Sigmanew= c*solve(t(X[,(p1+1):(p1+inc)])%*%X[,(p1+1):(p1+inc)])\n          zeta1n=beta1[b,(p1+1):(p1+inc)]\n          meannew=0\n          varnew = sqrt(Sigmanew)\n          zeta1=rnorm(1,meannew,varnew)\n          dn=log(dnorm(zeta1,meannew,varnew))\n          ###density old\n          do=log(dnorm(zeta1n,meannew,varnew))\n          beta=beta1[b,]\n          beta[(p1+1):(p1+inc)]=zeta1\n          Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n          Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n          alphab1m=Liken-Likeo+dn -do\n          U=log(runif(1,0,1))\n\n          if(is.finite(alphab1m)==FALSE){\n            Ind1s[b]=0\n          }else{\n            if(U>alphab1m){\n              Ind1s[b]=0\n            }else{Ind1s[b]=1\n            beta1[b,]=beta\n            zeta1n=zeta1\n            }}\n          ##End Inc Sampler\n        }else{\n          includednew=rep(0,p1)\n          for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n          includednew=includednew[includednew != 0]\n          zeta1n=beta1[b,c(includednew,(p1+1):(p1+inc))]\n\n          ###Make sigma matrices##\n          Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n          ####\n          p=length(includednew)+inc\n          ####Update All included variables\n\n          for(k in (length(includednew)+1):(length(includednew)+inc)){\n            zeta1=zeta1n\n            V1 = Sigmanew[k,k]\n            V2 = as.matrix(Sigmanew[-k,-k])\n            V12 = as.matrix(Sigmanew[k,-k])\n            thetano = as.matrix(zeta1[-k])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            zeta1[k]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(zeta1[k],meannew,varnew))\n            ###density old\n            do=log(dnorm(beta1[b,(p1+k-length(includednew))],meannew,varnew))\n\n\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,c(beta1[b,1:p1],zeta1n[(length(zeta1n)-inc+1):length(zeta1n)]),s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,c(beta1[b,1:p1],zeta1[(length(zeta1n)-inc+1):length(zeta1n)]),s1[b-1,],lam1[b-1,])\n\n            alphab1s=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n\n            if(is.finite(alphab1s)==FALSE){\n              Ins1s[b]=0\n\n            }else{\n\n              if(U>alphab1s){\n\n\n\n                Ind1s[b]=0\n\n              }else{Ind1s[b]=1\n              zeta1n=zeta1\n              beta1[b,]=c(beta1[b,1:p1],zeta1[(length(zeta1)-inc+1):length(zeta1)])\n\n              }\n            }\n\n          }\n\n          ###End included sampler###\n        }\n\n\n\n        #####Conditional Sampler for Included!###\n\n\n        if(sum(eta1[b,])>0){\n\n          iter[2]=\"Conditional Inclusion\"\n          ##Jointly Update nonzero betas\n          zeta1=beta1[b,]\n          zeta1=zeta1[zeta1!=0]\n          zeta1n=zeta1\n          Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n\n\n\n          ###############\n          ####\n\n          for(k in 1:length(includednew)){\n\n\n            V1 = Sigmanew[k,k]\n            V2 = as.matrix(Sigmanew[-k,-k])\n            V12 = as.matrix(Sigmanew[k,-k])\n            thetab=beta1[b,c(includednew,(p1+1):(p1+inc))]\n            thetano = as.matrix(thetab[-k])\n            meannew = t(V12)%*%solve(V2)%*%thetano\n            varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            ##################\n            zeta1n[k]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(zeta1n[k],meannew,varnew))\n            ###density old\n            do=log(dnorm(zeta1[k],meannew,varnew))\n\n\n\n\n\n\n            beta=beta1[b,]\n            beta[c(includednew,(p1+1):(p1+inc))]=zeta1n\n\n\n            Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n            alphab1m=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1m)==FALSE){\n              Indcond1[b,k]=0\n            }else{\n              if(U>alphab1m){\n                Indcond1[b,includednew[k]]=0\n                zeta1n[k]=zeta1[k]\n              }else{Indcond1[b,includednew[k]]=1\n              beta1[b,]=beta\n              zeta1[k]=zeta1n[k]\n              }}\n\n          }\n\n\n\n          ##Jointly Update nonzero betas\n          iter[2]=\"mixing\"\n          zeta1n=beta1[b,]\n          Sigmanew=c*solve(t(X[,c(includednew,(p1+1):(p1+inc))])%*%X[,c(includednew,(p1+1):(p1+inc))])\n\n\n          zeta1n[c(includednew,(p1+1):(p1+inc))]=rmvnorm(1,rep(0,length(includednew)+inc),Sigmanew)\n\n          beta=beta1[b,]\n          beta=beta[beta!=0]\n\n          dn=log(dmvnorm(zeta1n[c(includednew,(p1+1):(p1+inc))],rep(0,length(includednew)+inc),Sigmanew))\n          ###density old\n          do=log(dmvnorm(beta,rep(0,length(includednew)+inc),Sigmanew))\n\n          ######Accept reject###\n          Likeo=LK1(Y1,I1,X,beta1[b,], s1[b-1,],lam1[b-1,])\n          Liken=LK1(Y1,I1,X,zeta1n,s1[b-1,],lam1[b-1,])\n\n          alphamix1=Liken-Likeo+dn -do\n          U=log(runif(1,0,1))\n          if(is.finite(alphamix1)==FALSE){\n            Indmix1[b]=0\n          }else{\n            if(U>alphamix1){\n\n              Indmix1[b]=0\n            }else{Indmix1[b]=1\n            beta1[b,]=zeta1n\n            }}\n\n        }\n\n        S1=s1[b-1,]\n        S1=S1[!is.na(S1)]\n\n        L1=lam1[b-1,]\n        L1=as.matrix(L1[!is.na(L1)])\n\n\n        iter[1]=\"LogBH1\"\n        iter[2]=\"matrixsetup\"\n\n        W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n        Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n        length1=rep(0,J1+1)\n\n\n\n\n        for(j in 1:length(length1)){\n          length1[j]=s1[b-1,j+1]-s1[b-1,j]\n        }\n\n\n        if(J1<2){\n          if(J1==1){\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n          }else{\n\n            Q1=as.matrix(2/(m1))\n            SigLam1=Q1\n          }\n        }else{\n\n\n          for(j in 2:J1){\n            W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n          }\n\n\n          Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n          Q1[1,1]=2/(2*length1[1]+length1[2])\n          W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n          W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n          SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n        }\n\n\n\n        iter[2]=\"Mu\"\n        ##Lambda1 Hierarchical Sampler\n        ##Mulam\n\n        if(J1>0){\n\n          Mulam1[b]=rnorm(1,(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%L1)/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1))),sqrt(Siglam1[b-1]/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1)))))\n\n\n          Siglam1[b]=1/rgamma(1,a1+(J1+1)/2,b1+.5*(t(as.matrix(rep(Mulam1[b],J1+1))-L1)%*%solve(SigLam1)%*%(as.matrix(rep(Mulam1[b],J1+1))-L1)))\n\n\n          ##Siglam\n\n          iter[2]=\"Sigma\"\n        }else{\n\n\n\n          Mulam1[b]=rnorm(1,lam1[b-1,1],sqrt(Siglam1[b-1]))\n\n\n          Siglam1[b]=1/rgamma(1,a1+1/2,b1+.5*(Mulam1[b]-lam1[b-1,1])^2)\n\n\n\n        }\n\n        #if(is.finite(Mulam1[b])==FALSE){stop(\"Adjust Hierarchical Hyper-Parameters\")}\n        #if(is.finite(Siglam1[b])==FALSE){stop(\"Adjust Hierarchical Hyper-Parameters\")}\n\n\n\n        #lambda1\n        iter[2]=\"lam1\"\n        lam1[b,]=lam1[b-1,]\n        #######\n\n        for(m in 1:(J1+1)){\n\n\n\n          lam=lam1[b,]\n          lam=lam[is.na(lam)==FALSE]\n          lambda=lam\n\n          lam[m]=lambda[m]+runif(1,-cl1,cl1)\n\n\n          if(J1==0){\n            do=log(dnorm(lambda[m],Mulam1[b],sqrt(Siglam1[b])))\n            dn=log(dnorm(lam[m],Mulam1[b],sqrt(Siglam1[b])))\n          }else{\n\n\n            #do=-(t(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n            #dn=-(t(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n\n            do=dmvnorm(lambda,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n            do=dmvnorm(lam,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n          }\n\n          Likeo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n          Liken=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam)\n\n\n\n\n          U=log(runif(1,0,1))\n          alphalam=Liken-Likeo+dn-do\n\n          if(is.nan(alphalam)==TRUE){\n            lam1[b,m]=lam1[b-1,m]\n            Acceptlam1[b,m]=0\n          }else{\n\n            if(U<alphalam){\n              Acceptlam1[b,m]=1\n              lam1[b,m]=lam[m]\n            }else{Acceptlam1[b,m]=0}\n          }\n\n\n        }\n\n\n\n\n\n        #####################################################\n        ###################################################\n\n        iter[1]=\"Haz1\"\n        iter[2]=\"Birth\"\n\n        ###Random Perturbation###\n        U1=runif(1,0,1)\n        #####\n\n        s=s1[b-1,]\n        s=s[!is.na(s)]\n\n        if(length(s)<J1max){\n          Birth=runif(1,0,m1)\n\n          s1[b,1:(J1+3)]=sort(c(s,Birth))\n\n          for(k in 2:(J1+2)){\n            if(Birth>s1[b-1,k-1] & Birth<s1[b-1,k]){\n              Ind=k-1\n            }\n          }\n\n          lam=rep(0,J1+2)\n\n          if(Ind==1 | Ind==J1+1){\n            if(Ind==1){\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n            }else{\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            }\n          }else{\n            lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n          }\n\n          lam=lam[!is.na(lam)]\n\n          lambda=lam1[b,]\n          lambda=lambda[!is.na(lambda)]\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n\n          if(J1>0){\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n          }else{\n            do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n          }\n\n          prior=((2*J1+3)*(2*J1+2)*(Birth-s1[b-1,Ind])*(s1[b-1,Ind+1]-Birth))/((m1^2)*(s1[b-1,Ind+1]-s1[b-1,Ind]))\n\n          G1=G1+1\n          J1=J1+1\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam)\n\n\n\n          ##Make SigLam1\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n          }\n\n\n\n          dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),Siglam1[b]*SigLam1n))\n\n\n\n\n          alpha=Ln-Lo+dn-do-log(U1*(1-U1)) + log(prior)\n\n          if(is.nan(alpha)==TRUE){\n            IndB1[b]=0\n            s1[b,]=s1[b-1,]\n            J1=J1-1\n            G1=G1-1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            if(U<alpha){\n              IndB1[b]=1\n              lam1[b,1:(J1+1)]=lam\n            }else{\n              s1[b,]=s1[b-1,]\n              IndB1[b]=0\n              J1=J1-1\n              G1=G1-1\n            }\n\n          }\n\n\n        }else{\n          s1[b,]=s1[b-1,]\n          IndB1[b]=0\n        }\n\n\n        #########################################################\n        ###################Death Sampler#########################\n        ##########################################################\n        iter[2]=\"Death\"\n\n        U1=runif(1,0,1)\n\n        if(J1==0){\n          IndD1[b]=0\n          s1[b,]=s1[b-1,]\n        }else{\n\n          if(J1==1){\n            Ind=2\n          }else{\n\n            Ind=sample(2:(J1+1),1)\n          }\n\n\n          s=s1[b,]\n          s=s[-Ind]\n\n          lam=lam1[b,]\n          lambda=lam[!is.na(lam)]\n\n          lam=lam[!is.na(lam)]\n          lam=lam[-Ind]\n\n          lam[Ind-1]=((s1[b,Ind]-s1[b,Ind-1])*lam1[b,Ind-1]+(s1[b,Ind+1]-s1[b,Ind])*lam1[b,Ind])/(s1[b,Ind+1]-s1[b,Ind-1])\n\n\n\n          #############################################\n          ####Sets up SigLam1 matrix for old density###\n          #############################################\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n              do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n\n\n            }else{\n\n\n              do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n          }\n          #############################################\n          #############################################\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam1[b,])\n\n\n\n          prior=((m1^2)*(s1[b,Ind+1]-s1[b,Ind-1]))/((2*J1+1)*(2*J1)*(s1[b,Ind]-s1[b,Ind-1])*(s1[b,Ind+1]-s1[b,Ind]))\n\n\n          G1=G1-1\n          J1=J1-1\n\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]), s,lam)\n\n\n          ###Make siglam matrix\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n\n          length1=rep(0,J1+1)\n\n\n\n\n          for(j in 1:length(length1)){\n            length1[j]=s[j+1]-s[j]\n          }\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n              dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n              dn=log(dpois(J1,alpha1))+log(dnorm(lam,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n            dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n          }\n          ####\n\n\n\n\n          alpha=Ln-Lo+dn-do+log(prior)+log(U1*(1-U1))\n\n          if(is.nan(alpha)==TRUE){\n            IndD1[b]=0\n            J1=J1+1\n            G1=G1+1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            iter[2]=\"AcceptRejDeath\"\n\n            if(U<alpha){\n              s1[b,]=c(s,NA)\n              IndD1[b]=1\n              lam1[b,1:(J1+1)]=lam\n              lam1[b,(J1+2):J1max]=rep(NA,J1max-J1-1)\n            }else{\n              IndD1[b]=0\n              J1=J1+1\n              G1=G1+1\n            }\n          }\n\n          ####End else\n        }\n        ##\n\n\n\n\n\n        split1[b]=J1\n\n        sum1[b]=sum(eta1[b,])\n\n\n      }\n\n\n\n\n\n      ################End Samplers\n      cat(c,z1a,z1b,\"\n\n\n\n\n          \", \"\n\n\n\n          \", \"\n\n\n          \", \"Posterior Inclusion Probabilities after half Burnin\", \"\n\n\n          \", \"Hazard 1\", \"\n\n          \", colMeans(eta1[(B*burn+1):B,])*100, \"\n\n\n          \", \"IndEta\",mean(Indeta1[(B*burn+1):B])*100,\"\n\n\n          \",\"IndMix\",mean(Indmix1[(B*burn+1):B])*100,\"\n\n\n          \", \"Included Acceptance\", \"\n\n          \", \"Haz1\", \"\n          \", mean(Ind1s[(B*burn+1):B])*100, \"\n\n          \", colMeans(Indcond1[(B*burn+1):B,],na.rm=TRUE)*100,\"\n\n\n\n\n          \",\"Survival\",\"\n\n          \",\"IndDeath\",mean(IndD1[(B*burn+1):B])*100,\"\n\n          \",\"IndBirth\",mean(IndB1[(B*burn+1):B])*100,\"\n\n          \",\"Lambda\",\"\n\n          \", \"Lam1\",\n          colMeans(Acceptlam1[(B*burn+1):B,],na.rm=TRUE)*100)\n\n\n\n\n      Path1= paste0(Path,\"/Ind1s.txt\")\n\n      write.table(Ind1s[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n\n      par(mfrow=c(2,1))\n\n      plot(1:B,sum1,type=\"l\",xlab=\"\",ylab=\"Haz: # Included\", main=\"Traceplot: # Included\")\n\n\n\n      plot(1:B,split1,type=\"l\",xlab=\"\",ylab=\"Haz: Split #\", main=\"Traceplot: # Split points\")\n\n\n\n    }\n\n\n\n    ###If 0 inc\n\n\n\n    if(inc==0){\n\n      cat(\"No Variables Included\")\n\n      for(b in 2:B){\n\n\n        if(b%%10000==0){cat(b, \"iterations\",date(), \"  \")}else{\n          if(b%%5000==0){cat(b, \" iterations \")}}\n\n\n\n\n        ###eta1,beta1\n        eta1[b,]=eta1[b-1,]\n        beta1[b,]=beta1[b-1,]\n\n        if(sum(eta1[b-1,])==0|sum(eta1[b-1,])==p1){\n          if(sum(eta1[b-1,])==0){\n            ###Add Automatically\n            Ind=sample(1:p1,1)\n            eta1[b,Ind]=1\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n            spotnew=rep(0,length(includednew))\n            for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n            spot2=max(spotnew)\n            ###Make sigma matrices##\n            Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n            ####\n\n            meannew = 0\n            varnew = sqrt(Sigmanew)\n            ##################\n            beta1[b,Ind]=rnorm(1,meannew,varnew)\n            dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n            ######Accept reject###\n\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n\n            if(U>alphab1){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{Indeta1[b]=1}\n          }\n          if(sum(eta1[b-1,])==p1){\n            ###Delete Automatically\n            Ind=sample(1:p1,1)\n            eta1[b,Ind]=0\n            beta1[b,Ind]=0\n            includedold=rep(0,p1)\n            for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n            includedold=includedold[includedold != 0]\n            spotold=rep(0,length(includedold))\n            for(k in 1:length(includedold)){if(includedold[k]==Ind){spotold[k]=k}}\n            spot1=max(spotold)\n\n\n            ###Make sigma matrices##\n            Sigmaold=c*solve(t(X[,includedold])%*%X[,includedold])\n\n            ###Old density###\n            V1 = Sigmaold[spot1,spot1]\n            V2 = as.matrix(Sigmaold[-spot1,-spot1])\n            V12 = as.matrix(Sigmaold[spot1,-spot1])\n            thetab=beta1[b-1,includedold]\n            thetano = as.matrix(thetab[-spot1])\n            meanold = t(V12)%*%solve(V2)%*%thetano\n            varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n            do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n            alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n            U=log(runif(1,0,1))\n\n            if(U>alphab1){\n              eta1[b,]=eta1[b-1,]\n              beta1[b,]=beta1[b-1,]\n              Indeta1[b]=0\n            }else{Indeta1[b]=1}\n          }\n        }else{\n\n          U=runif(1,0,1)\n\n          if(U<psi){\n\n            if(sum(eta1[b-1,])==1){\n\n              includedold=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n              includedold=includedold[includedold != 0]\n              ones=includedold\n              zeros=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==0){zeros[k]=k}}\n              zeros=zeros[zeros != 0]\n              ###Sample swap indices###\n              Indone=ones\n              Indzero=sample(zeros,1)\n              ####Change Beta/eta\n              eta1[b,Indone]=0\n              eta1[b,Indzero]=1\n              beta1[b,Indone]=0\n              ##\n\n              Sigmaold=c*solve(t(X[,Indone])%*%X[,Indone])\n              Sigmanew=c*solve(t(X[,Indzero])%*%X[,Indzero])\n\n              meannew = 0\n              varnew = sqrt(Sigmanew)\n              ##################\n              beta1[b,Indzero]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(beta1[b,Indzero],meannew,varnew))\n              ###Old density###\n\n              meanold = 0\n              varold = sqrt(Sigmaold)\n              do=log(dnorm(beta1[b-1,Indone],meanold,varold))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo+dn-do\n              U=log(runif(1,0,1))\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }else{\n\n\n\n              ###Swapper\n              includedold=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n              includedold=includedold[includedold != 0]\n              ones=includedold\n              zeros=rep(0,p1)\n              for(k in 1:p1){if(eta1[b-1,k]==0){zeros[k]=k}}\n              zeros=zeros[zeros != 0]\n              ###Sample swap indices###\n              Indone=sample(ones,1)\n              Indzero=sample(zeros,1)\n              ####Change Beta/eta\n              eta1[b,Indone]=0\n              eta1[b,Indzero]=1\n              includednew=rep(0,p1)\n              for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n              includednew=includednew[includednew != 0]\n              spotold=rep(0,length(includedold))\n              for(k in 1:length(includedold)){if(Indone==includedold[k]){spotold[k]=k}}\n              spot1=max(spotold)\n              spotnew=rep(0,length(includednew))\n              for(k in 1:length(includednew)){if(Indzero==includednew[k]){spotnew[k]=k}}\n              spot2=max(spotnew)\n              ###Make sigma matrices##\n              Sigmaold=c*solve(t(X[,includedold])%*%X[,includedold])\n              Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n              ###Generate new vector##\n              beta1[b,Indone]=0\n\n              ##meannew,varnew##\n              V1 = Sigmanew[spot2,spot2]\n              V2 = as.matrix(Sigmanew[-spot2,-spot2])\n              V12 = as.matrix(Sigmanew[spot2,-spot2])\n              thetab=beta1[b-1,includednew]\n              thetano = as.matrix(thetab[-spot2])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              beta1[b,Indzero]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(beta1[b,Indzero],meannew,varnew))\n              ###Old density###\n              V1 = Sigmaold[spot1,spot1]\n              V2 = as.matrix(Sigmaold[-spot1,-spot1])\n              V12 = as.matrix(Sigmaold[spot1,-spot1])\n              thetab=beta1[b-1,includedold]\n              thetano = as.matrix(thetab[-spot1])\n              meanold = t(V12)%*%solve(V2)%*%thetano\n              varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              do=log(dnorm(beta1[b-1,Indone],meanold,varold))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo+dn-do\n              U=log(runif(1,0,1))\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n            }\n\n          }else{\n            ###Add/Delete\n            Ind=sample(1:p1,1)\n            if(eta1[b-1,Ind]==1){\n              ##delete##\n\n              if(sum(eta1[b-1,])==1){\n\n\n                eta1[b,Ind]=0\n                beta1[b,Ind]=0\n                includedold=rep(0,p1)\n                for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n                includedold=includedold[includedold != 0]\n                spotold=rep(0,length(includedold))\n                for(k in 1:length(includedold)){if(Ind==includedold[k]){spotold[k]=k}}\n                spot1=max(spotold)\n\n\n                ###Make sigma matrices##\n                Sigmaold=c*solve(t(X[,includedold])%*%X[,includedold])\n\n                ###Old density###\n                V1 = Sigmaold[spot1,spot1]\n                V2 = as.matrix(Sigmaold[-spot1,-spot1])\n                V12 = as.matrix(Sigmaold[spot1,-spot1])\n                thetab=beta1[b-1,includedold]\n                thetano = as.matrix(thetab[-spot1])\n                meanold = 0\n                varold = sqrt(Sigmaold)\n                do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n                ######Accept reject###\n                Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n                Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n                alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n                U=log(runif(1,0,1))\n\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n\n\n\n              }else{\n\n\n                eta1[b,Ind]=0\n                beta1[b,Ind]=0\n                includedold=rep(0,p1)\n                for(k in 1:p1){if(eta1[b-1,k]==1){includedold[k]=k}}\n                includedold=includedold[includedold != 0]\n                spotold=rep(0,length(includedold))\n                for(k in 1:length(includedold)){if(Ind==includedold[k]){spotold[k]=k}}\n                spot1=max(spotold)\n\n\n                ###Make sigma matrices##\n                Sigmaold=c*solve(t(X[,includedold])%*%X[,includedold])\n\n                ###Old density###\n                V1 = Sigmaold[spot1,spot1]\n                V2 = as.matrix(Sigmaold[-spot1,-spot1])\n                V12 = as.matrix(Sigmaold[spot1,-spot1])\n                thetab=beta1[b-1,includedold]\n                thetano = as.matrix(thetab[-spot1])\n                meanold = t(V12)%*%solve(V2)%*%thetano\n                varold = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n                do=log(dnorm(beta1[b-1,Ind],meanold,varold))\n                ######Accept reject###\n                Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n                Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n                alphab1=Liken-Likeo-do + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n                U=log(runif(1,0,1))\n\n                if(U>alphab1){\n                  eta1[b,]=eta1[b-1,]\n                  beta1[b,]=beta1[b-1,]\n                  Indeta1[b]=0\n                }else{Indeta1[b]=1}\n\n              }\n\n\n            }else{\n              ###Add###\n\n\n\n              eta1[b,Ind]=1\n\n\n              includednew=rep(0,p1)\n              for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n              includednew=includednew[includednew != 0]\n              spotnew=rep(0,length(includednew))\n              for(k in 1:length(includednew)){if(Ind==includednew[k]){spotnew[k]=k}}\n              spot2=max(spotnew)\n              ###Make sigma matrices##\n              Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n              ####\n              V1 = Sigmanew[spot2,spot2]\n              V2 = as.matrix(Sigmanew[-spot2,-spot2])\n              V12 = as.matrix(Sigmanew[spot2,-spot2])\n              thetab=beta1[b-1,includednew]\n              thetano = as.matrix(thetab[-spot2])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              beta1[b,Ind]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(beta1[b,Ind],meannew,varnew))\n              ######Accept reject###\n              Likeo=LK1(Y1,I1,X,beta1[b-1,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n\n              alphab1=Liken-Likeo+dn + log(beta(sum(eta1[b,])+z1a,p1-sum(eta1[b,])+z1b)) - log(beta(sum(eta1[b-1,])+z1a,p1-sum(eta1[b-1,])+z1b))\n              U=log(runif(1,0,1))\n\n              if(U>alphab1){\n                eta1[b,]=eta1[b-1,]\n                beta1[b,]=beta1[b-1,]\n                Indeta1[b]=0\n              }else{Indeta1[b]=1}\n\n\n\n            }\n\n          }\n\n        }\n\n        ##End Eta Beta\n\n        includednew=rep(0,p1)\n        for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n        includednew=includednew[includednew != 0]\n\n        if(sum(eta1[b,])>0){\n\n\n          if(sum(eta1[b,])==1){\n\n            iter[2]=\"Conditional Inclusion\"\n\n\n            includednew=rep(0,p1)\n            for(k in 1:p1){if(eta1[b,k]==1){includednew[k]=k}}\n            includednew=includednew[includednew != 0]\n\n            Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n\n\n\n            meannew = 0\n            varnew = sqrt(Sigmanew)\n\n            beta=beta1[b,]\n\n            ##################\n            beta[includednew]=rnorm(1,meannew,varnew)\n\n            dn=log(dnorm(beta[includednew],meannew,varnew))\n            ###density old\n            do=log(dnorm(beta1[b,includednew],meannew,varnew))\n\n\n\n\n\n\n\n            Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n            alphab1m=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n            if(is.finite(alphab1m)==FALSE){\n              Indcond1[b,includednew]=0\n            }else{\n              if(U>alphab1m){\n                Indcond1[b,includednew]=0\n              }else{Indcond1[b,includednew]=1\n              beta1[b,]=beta\n              }}\n\n          }else{\n\n            iter[2]=\"Conditional Inclusion\"\n            ##Jointly Update nonzero betas\n            zeta1=beta1[b,]\n            zeta1=zeta1[zeta1!=0]\n            zeta1n=zeta1\n            Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n\n\n\n            ###############\n            ####\n\n            for(k in 1:length(includednew)){\n\n\n              V1 = Sigmanew[k,k]\n              V2 = as.matrix(Sigmanew[-k,-k])\n              V12 = as.matrix(Sigmanew[k,-k])\n              thetab=beta1[b,includednew]\n              thetano = as.matrix(thetab[-k])\n              meannew = t(V12)%*%solve(V2)%*%thetano\n              varnew = sqrt(V1 - t(V12)%*%solve(V2)%*%V12)\n              ##################\n              zeta1n[k]=rnorm(1,meannew,varnew)\n              dn=log(dnorm(zeta1n[k],meannew,varnew))\n              ###density old\n              do=log(dnorm(zeta1[k],meannew,varnew))\n\n\n\n\n\n\n              beta=beta1[b,]\n              beta[includednew]=zeta1n\n\n\n              Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n              Liken=LK1(Y1,I1,X,beta,s1[b-1,],lam1[b-1,])\n\n              alphab1m=Liken-Likeo+dn -do\n              U=log(runif(1,0,1))\n              if(is.finite(alphab1m)==FALSE){\n                Indcond1[b,includednew[k]]=0\n              }else{\n                if(U>alphab1m){\n                  Indcond1[b,includednew[k]]=0\n                  zeta1n[k]=zeta1[k]\n                }else{Indcond1[b,includednew[k]]=1\n                beta1[b,]=beta\n                zeta1[k]=zeta1n[k]\n                }}\n\n            }\n\n\n\n            ##Jointly Update nonzero betas\n            iter[2]=\"mixing\"\n            zeta1n=beta1[b,]\n            Sigmanew=c*solve(t(X[,includednew])%*%X[,includednew])\n\n\n            zeta1n[includednew]=rmvnorm(1,rep(0,length(includednew)),Sigmanew)\n\n            beta=beta1[b,]\n            beta=beta[beta!=0]\n\n            dn=log(dmvnorm(zeta1n[includednew],rep(0,length(includednew)),Sigmanew))\n            ###density old\n            do=log(dmvnorm(beta,rep(0,length(includednew)),Sigmanew))\n\n            ######Accept reject###\n            Likeo=LK1(Y1,I1,X,beta1[b,],s1[b-1,],lam1[b-1,])\n            Liken=LK1(Y1,I1,X,zeta1n,s1[b-1,],lam1[b-1,])\n\n            alphamix1=Liken-Likeo+dn -do\n            U=log(runif(1,0,1))\n            if(is.finite(alphamix1)==FALSE){\n              Indmix1[b]=0\n            }else{\n              if(U>alphamix1){\n\n                Indmix1[b]=0\n              }else{Indmix1[b]=1\n              beta1[b,]=zeta1n\n              }}\n\n          }\n\n\n\n        }\n\n\n\n\n\n        S1=s1[b-1,]\n        S1=S1[!is.na(S1)]\n\n\n        L1=lam1[b-1,]\n        L1=as.matrix(L1[!is.na(L1)])\n\n\n        ############################################\n        #####Start LogBH Samplers###################\n        ############################################\n        ####Lam1####\n\n        iter[1]=\"LogBH1\"\n        iter[2]=\"matrixsetup\"\n\n        W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n        Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n        length1=rep(0,J1+1)\n\n\n\n\n        for(j in 1:length(length1)){\n          length1[j]=s1[b-1,j+1]-s1[b-1,j]\n        }\n\n\n        if(J1<2){\n          if(J1==1){\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n          }else{\n\n            Q1=as.matrix(2/(m1))\n            SigLam1=Q1\n          }\n        }else{\n\n\n          for(j in 2:J1){\n            W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n            Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n          }\n\n\n          Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n          Q1[1,1]=2/(2*length1[1]+length1[2])\n          W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n          W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n          SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n        }\n\n\n\n        iter[2]=\"Mu\"\n        ##Lambda1 Hierarchical Sampler\n        ##Mulam\n\n        if(J1>0){\n\n          Mulam1[b]=rnorm(1,(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%L1)/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1))),sqrt(Siglam1[b-1]/(t(as.matrix(rep(1,J1+1)))%*%solve(SigLam1)%*%as.matrix(rep(1,J1+1)))))\n\n\n          Siglam1[b]=1/rgamma(1,a1+(J1+1)/2,b1+.5*(t(as.matrix(rep(Mulam1[b],J1+1))-L1)%*%solve(SigLam1)%*%(as.matrix(rep(Mulam1[b],J1+1))-L1)))\n\n\n          ##Siglam\n\n          iter[2]=\"Sigma\"\n        }else{\n\n\n\n          Mulam1[b]=rnorm(1,lam1[b-1,1],sqrt(Siglam1[b-1]))\n\n\n          Siglam1[b]=1/rgamma(1,a1+1/2,b1+.5*(Mulam1[b]-lam1[b-1,1])^2)\n\n\n\n        }\n\n        #if(is.finite(Mulam1[b])==FALSE){stop(\"Adjust Hierarchical Hyper-Parameters\")}\n        #if(is.finite(Siglam1[b])==FALSE){stop(\"Adjust Hierarchical Hyper-Parameters\")}\n\n\n\n        #lambda1\n        iter[2]=\"lam1\"\n        lam1[b,]=lam1[b-1,]\n        #######\n\n        for(m in 1:(J1+1)){\n\n\n\n          lam=lam1[b,]\n          lam=lam[is.na(lam)==FALSE]\n          lambda=lam\n\n          lam[m]=lambda[m]+runif(1,-cl1,cl1)\n\n\n          if(J1==0){\n            do=log(dnorm(lambda[m],Mulam1[b],sqrt(Siglam1[b])))\n            dn=log(dnorm(lam[m],Mulam1[b],sqrt(Siglam1[b])))\n          }else{\n\n\n            #do=-(t(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lambda)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n            #dn=-(t(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1)))%*%solve(SigLam1)%*%(as.matrix(lam)-as.matrix(rep(Mulam1[b],J1+1))))/(2*Siglam1[b])\n\n\n            do=dmvnorm(lambda,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n            do=dmvnorm(lam,rep(Mulam1[b],J1+1),Siglam1[b]*SigLam1)\n          }\n\n          Likeo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n          Liken=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam)\n\n\n          U=log(runif(1,0,1))\n          alphalam=Liken-Likeo+dn-do\n\n          if(is.nan(alphalam)==TRUE){\n            lam1[b,m]=lam1[b-1,m]\n            Acceptlam1[b,m]=0\n          }else{\n\n            if(U<alphalam){\n              Acceptlam1[b,m]=1\n              lam1[b,m]=lam[m]\n            }else{Acceptlam1[b,m]=0}\n          }\n\n\n        }\n\n\n\n\n\n\n        #############################################\n        ###################################################\n\n        iter[1]=\"Haz1\"\n        iter[2]=\"Birth\"\n\n        ###Random Perturbation###\n        U1=runif(1,0,1)\n        #####\n\n        s=s1[b-1,]\n        s=s[!is.na(s)]\n\n        if(length(s)<J1max){\n          Birth=runif(1,0,m1)\n\n          s1[b,1:(J1+3)]=sort(c(s,Birth))\n\n          for(k in 2:(J1+2)){\n            if(Birth>s1[b-1,k-1] & Birth<s1[b-1,k]){\n              Ind=k-1\n            }\n          }\n\n          lam=rep(0,J1+2)\n\n          if(Ind==1 | Ind==J1+1){\n            if(Ind==1){\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n            }else{\n              lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n              lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            }\n          }else{\n            lam[Ind]=lam1[b,Ind] - ((s1[b-1,Ind+1]-Birth)/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[Ind+1]=lam1[b,Ind] + ((Birth-s1[b-1,Ind])/(s1[b-1,Ind+1]-s1[b-1,Ind]))*log((1-U1)/U1)\n            lam[1:(Ind-1)]=lam1[b,1:(Ind-1)]\n            lam[(Ind+2):length(lam)]=lam1[b,(Ind+1):(J1+1)]\n          }\n\n          lam=lam[!is.na(lam)]\n\n          lambda=lam1[b,]\n          lambda=lambda[!is.na(lambda)]\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b-1,],lam1[b,])\n\n\n\n          if(J1>0){\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n          }else{\n            do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n          }\n\n          prior=((2*J1+3)*(2*J1+2)*(Birth-s1[b-1,Ind])*(s1[b-1,Ind+1]-Birth))/((m1^2)*(s1[b-1,Ind+1]-s1[b-1,Ind]))\n\n          G1=G1+1\n          J1=J1+1\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam)\n\n\n\n          ##Make SigLam1\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n          }\n\n\n\n          dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),Siglam1[b]*SigLam1n))\n\n\n\n\n          alpha=Ln-Lo+dn-do-log(U1*(1-U1)) + log(prior)\n\n          if(is.nan(alpha)==TRUE){\n            IndB1[b]=0\n            s1[b,]=s1[b-1,]\n            J1=J1-1\n            G1=G1-1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            if(U<alpha){\n              IndB1[b]=1\n              lam1[b,1:(J1+1)]=lam\n            }else{\n              s1[b,]=s1[b-1,]\n              IndB1[b]=0\n              J1=J1-1\n              G1=G1-1\n            }\n\n          }\n\n\n        }else{\n          s1[b,]=s1[b-1,]\n          IndB1[b]=0\n        }\n\n\n        #########################################################\n        ###################Death Sampler#########################\n        ##########################################################\n        iter[2]=\"Death\"\n\n        U1=runif(1,0,1)\n\n        if(J1==0){\n          IndD1[b]=0\n          s1[b,]=s1[b-1,]\n        }else{\n\n          if(J1==1){\n            Ind=2\n          }else{\n\n            Ind=sample(2:(J1+1),1)\n          }\n\n\n          s=s1[b,]\n          s=s[-Ind]\n\n          lam=lam1[b,]\n          lambda=lam[!is.na(lam)]\n\n          lam=lam[!is.na(lam)]\n          lam=lam[-Ind]\n\n          lam[Ind-1]=((s1[b,Ind]-s1[b,Ind-1])*lam1[b,Ind-1]+(s1[b,Ind+1]-s1[b,Ind])*lam1[b,Ind])/(s1[b,Ind+1]-s1[b,Ind-1])\n\n\n\n          #############################################\n          ####Sets up SigLam1 matrix for old density###\n          #############################################\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n          length1=diff(s1[b,])\n\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n              do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n\n\n            }else{\n\n\n              do=log(dpois(J1,alpha1))+log(dnorm(lambda,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1=solve(diag(J1+1)-W1)%*%Q1\n\n            do=log(dpois(J1,alpha1))+log(dmvnorm(lambda,rep(Mulam1[b],length(lambda)),SigLam1*Siglam1[b]))\n\n\n          }\n          #############################################\n          #############################################\n\n          Lo=LK1L(Y1,I1,X,as.matrix(beta1[b,]),s1[b,],lam1[b,])\n\n\n\n          prior=((m1^2)*(s1[b,Ind+1]-s1[b,Ind-1]))/((2*J1+1)*(2*J1)*(s1[b,Ind]-s1[b,Ind-1])*(s1[b,Ind+1]-s1[b,Ind]))\n\n\n          G1=G1-1\n          J1=J1-1\n\n\n          Ln=LK1L(Y1,I1,X,as.matrix(beta1[b,]), s,lam)\n\n\n          ###Make siglam matrix\n\n\n\n          W1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n          Q1=matrix(rep(0,(J1+1)*(J1+1)),nrow=J1+1)\n\n\n\n          length1=rep(0,J1+1)\n\n\n\n\n          for(j in 1:length(length1)){\n            length1[j]=s[j+1]-s[j]\n          }\n\n\n          if(J1<2){\n            if(J1==1){\n              W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n              W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n              Q1[1,1]=2/(2*length1[1]+length1[2])\n              Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n              SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n\n              dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n\n            }else{\n\n              SigLam1n=2/m1\n              dn=log(dpois(J1,alpha1))+log(dnorm(lam,Mulam1[b],Siglam1[b]))\n\n            }\n          }else{\n\n\n            for(j in 2:J1){\n              W1[j,j-1]=(clam1*(length1[j]+length1[j-1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              W1[j,j+1]=(clam1*(length1[j]+length1[j+1]))/(length1[j-1]+2*length1[j]+length1[j+1])\n              Q1[j,j]=2/(length1[j-1]+2*length1[j]+length1[j+1])\n            }\n\n\n            Q1[J1+1,J1+1]=2/(length1[J1]+2*length1[J1+1])\n            Q1[1,1]=2/(2*length1[1]+length1[2])\n            W1[1,2]=(clam1*(length1[1]+length1[2]))/(2*length1[1]+length1[2])\n            W1[J1+1,J1]=(clam1*(length1[J1+1]+length1[J1]))/(length1[J1]+2*length1[J1+1])\n\n\n            SigLam1n=solve(diag(J1+1)-W1)%*%Q1\n\n            dn=log(dpois(J1,alpha1))+log(dmvnorm(lam,rep(Mulam1[b],length(lam)),SigLam1n*Siglam1[b]))\n\n\n          }\n          ####\n\n\n\n\n          alpha=Ln-Lo+dn-do+log(prior)+log(U1*(1-U1))\n\n          if(is.nan(alpha)==TRUE){\n            IndD1[b]=0\n            J1=J1+1\n            G1=G1+1\n          }else{\n\n            U=log(runif(1,0,1))\n\n            iter[2]=\"AcceptRejDeath\"\n\n            if(U<alpha){\n              s1[b,]=c(s,NA)\n              IndD1[b]=1\n              lam1[b,1:(J1+1)]=lam\n              lam1[b,(J1+2):J1max]=rep(NA,J1max-J1-1)\n            }else{\n              IndD1[b]=0\n              J1=J1+1\n              G1=G1+1\n            }\n          }\n\n          ####End else\n        }\n        ##\n\n\n\n\n\n\n        #######################\n        #####End of Death sampler\n        ######################\n\n\n\n        split1[b]=J1\n\n        ##\n        sum1[b]=sum(eta1[b,])\n\n\n\n        ##End Sampler\n      }\n      ###End of Sampler\n\n\n\n\n      ################End Samplers\n      cat(c,z1a,z1b,\"\n\n\n\n\n          \", \"\n\n\n\n          \", \"\n\n\n          \", \"Posterior Inclusion Probabilities after half Burnin\", \"\n\n\n          \", \"Hazard\", \"\n\n          \", colMeans(eta1[(B*burn+1):B,])*100, \"\n\n\n          \", \"IndEta\",mean(Indeta1[(B*burn+1):B])*100,\"\n\n\n          \",\"IndMix\",mean(Indmix1[(B*burn+1):B])*100,\"\n\n\n          \", \"Included Acceptance\", \"\n\n          \", \"Hazard\", \"\n          \", \"\n\n          \", colMeans(Indcond1[(B*burn+1):B,],na.rm=TRUE)*100,\"\n\n\n\n          \",\"Survival\",\"\n\n          \",\"IndDeath\",mean(IndD1[(B*burn+1):B])*100,\"\n\n          \",\"IndBirth\",mean(IndB1[(B*burn+1):B])*100,\"\n\n          \",\"Lambda\",\"\n\n          \", \"Lam1\",\n          colMeans(Acceptlam1[(B*burn+1):B,],na.rm=TRUE)*100 )\n\n\n\n\n      ##End\n\n\n    }\n\n\n\n\n\n    ###Return Values\n\n\n\n    Path1= paste0(Path,\"/beta1.txt\")\n\n    write.table(beta1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/eta1.txt\")\n\n    write.table(eta1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n\n\n    Path1= paste0(Path,\"/lam1.txt\")\n\n    write.table(lam1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/s1.txt\")\n\n    write.table(s1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/sum1.txt\")\n\n    write.table(sum1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/split1.txt\")\n\n    write.table(split1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/siglam1.txt\")\n\n    write.table(Siglam1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n    Path1= paste0(Path,\"/mulam1.txt\")\n\n    write.table(Mulam1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/Indeta1.txt\")\n\n    write.table(Indeta1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n    Path1= paste0(Path,\"/IndD1.txt\")\n\n    write.table(IndD1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n    Path1= paste0(Path,\"/IndB1.txt\")\n\n    write.table(IndB1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n    Path1= paste0(Path,\"/Acceptlam1.txt\")\n\n    write.table(Acceptlam1[(burn*B+1):B,], Path1, sep=\"\\t\")\n\n\n\n\n\n\n\n\n    Path1= paste0(Path,\"/Indmix1.txt\")\n\n\n    write.table(Indmix1[(burn*B+1):B], Path1, sep=\"\\t\")\n\n\n\n\n\n\n\n\n\n    par(mfrow=c(2,1))\n\n    plot(1:B,sum1,type=\"l\",xlab=\"\",ylab=\" # Included\", main=\"Traceplot: # Included\")\n\n\n\n    plot(1:B,split1,type=\"l\",xlab=\"\",ylab=\"Hazard: Split #\", main=\"Traceplot: # Split points\")\n\n\n  }\n}\n\n\n\n\n\n\n\n",
    "created" : 1509033466576.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3040848559",
    "id" : "45C02274",
    "lastKnownWriteTime" : 1485265875,
    "last_content_update" : 1485265875,
    "path" : "D:/Users/Andrew/Desktop/PiecewiseBayesSelect/R/PiecewiseBayesSelect.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}