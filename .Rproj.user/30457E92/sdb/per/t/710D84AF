{
    "collab_server" : "",
    "contents" : "#include \"RcppArmadillo.h\"\n#include <time.h>\n#include <Rmath.h>\n#include <math.h>\n#define ARMA_DONT_PRINT_ERRORS\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <iostream>     // std::cout\n#include <cmath>\n#include <cfloat>\n#include <stdio.h>\n#include <float.h>\n#define PI 3.14159265\n\n\n// [[Rcpp::depends(RcppArmadillo)]]\n\n\n\nusing namespace Rcpp;\n\n\nint Sample2(arma::vec groupprob){\n  arma::vec cumprob=groupprob;\n  int m=0;\n\n  for(m=1;m<groupprob.n_rows;m++){\n    cumprob[m]=cumprob[m]+cumprob[m-1];\n  }\n  //Now we have the vector of cumulative probabilities, let's draw a random unif\n  double U=as_scalar(arma::randu(1));\n\n  int Which=0;\n\n\n  if(U<cumprob[0]){\n    Which=0;\n  }else{\n\n    for(m=0;m<(groupprob.n_rows-2);m++){\n      if(U>cumprob[m] & U<cumprob[m+1]){\n        Which=m+1;\n      }\n\n    }\n\n    if(U>cumprob[groupprob.n_rows-2]){\n      Which=groupprob.n_rows -1;\n    }\n\n\n  }\n\n\n  return(Which);\n\n}\n\n\n\nint GetFullyFollowed(arma::vec Y, //Survival Times\n                     arma::vec I, //Censoring Indicators\n                     arma::vec Doses, //Doses given to patients\n                     arma::vec Dose, //Standardized doses in consideration in trial\n                     double T1){\n  int sum1=0;\n\n  int m=0;\n\n  for(m=0;m<Y.n_rows;m++){\n    if(Doses[m]==Dose[0]){\n      if(I[m]==1){\n        sum1++;\n      }\n\n      if(Y[m]==T1){\n        sum1++;\n      }\n\n\n\n\n    }\n\n\n  }\n\n\n\n\n\n  return(sum1);\n\n\n}\n\n\n\ndouble MaxVec(arma::vec Y){\n  int J1=Y.n_rows;\n  int j=0;\n  double max=Y[0];\n  for(j=1;j<J1;j++){\n    if(Y[j]>max){\n      max=Y[j];\n    }\n  }\n\n  return(max);\n\n}\n\narma::vec ReturnStoppedY(arma::vec Y, arma::vec I,arma::vec Groups, arma::vec StoppedGroups, int i){\n\n\n//How many entries are NOT Stopped\nint m=0;\nint count=0;\narma::vec IN(i);\nIN.zeros();\nint k=0;\nfor(m=0;m<i;m++){\n  for(k=0;k<StoppedGroups.n_rows;k++){\n  if(Groups[m]==k){\n    if(StoppedGroups[k]==0){\n      count++;\n      IN[m]=1;\n    }\n  }\n\n  }\n}\n\narma::vec Y1(count);\narma::vec I1(count);\narma::vec Groups1(count);\nk=0;\n\nfor(m=0;m<count;m++){\n  while(IN[k]==0){\n  k++;\n  }\n\n  Y1[m]=Y[k];\n  I1[m]=I[k];\n  Groups1[m]=Groups[k];\n  k=k+1;\n}\n\n\n\n\n\n\n\n\n  return(Y1);\n\n\n}\n\narma::vec ReturnStoppedI(arma::vec Y, arma::vec I,arma::vec Groups, arma::vec StoppedGroups, int i){\n\n\n  //How many entries are NOT Stopped\n  int m=0;\n  int count=0;\n  arma::vec IN(i);\n  IN.zeros();\n  int k=0;\n  for(m=0;m<i;m++){\n    for(k=0;k<StoppedGroups.n_rows;k++){\n      if(Groups[m]==k){\n        if(StoppedGroups[k]==0){\n          count++;\n          IN[m]=1;\n        }\n      }\n\n    }\n  }\n\n  arma::vec Y1(count);\n  arma::vec I1(count);\n  arma::vec Groups1(count);\n  k=0;\n\n  for(m=0;m<count;m++){\n    while(IN[k]==0){\n      k++;\n    }\n\n    Y1[m]=Y[k];\n    I1[m]=I[k];\n    Groups1[m]=Groups[k];\n    k=k+1;\n  }\n\n\n\n\n\n\n\n\n  return(I1);\n\n\n}\n\narma::vec ReturnStoppedGroups(arma::vec Y, arma::vec I,arma::vec Groups, arma::vec StoppedGroups, int i){\n\n\n  //How many entries are NOT Stopped\n  int m=0;\n  int count=0;\n  arma::vec IN(i);\n  IN.zeros();\n  int k=0;\n  for(m=0;m<i;m++){\n    for(k=0;k<StoppedGroups.n_rows;k++){\n      if(Groups[m]==k){\n        if(StoppedGroups[k]==0){\n          count++;\n          IN[m]=1;\n        }\n      }\n\n    }\n  }\n\n  arma::vec Y1(count);\n  arma::vec I1(count);\n  arma::vec Groups1(count);\n  k=0;\n\n  for(m=0;m<count;m++){\n    while(IN[k]==0){\n      k++;\n    }\n\n    Y1[m]=Y[k];\n    I1[m]=I[k];\n    Groups1[m]=Groups[k];\n    k=k+1;\n  }\n\n\n\n\n\n\n\n\n  return(Groups1);\n\n\n}\n\n\n\n\n\n\n\n\ndouble MinVec(arma::vec Y){\n  int J1=Y.n_rows;\n  int j=0;\n  double max=Y[0];\n  for(j=1;j<J1;j++){\n    if(Y[j]<max){\n      max=Y[j];\n    }\n  }\n\n  return(max);\n\n}\n\n\ndouble min1(double a, double b){\n  double z=0;\n  if(a>=b){\n    z=b;\n  }else{\n    z=a;\n  }\n\n  return(z);\n}\n\n\n\ndouble max1(double a, double b){\n  double z=0;\n  if(a>=b){\n    z=a;\n  }else{\n    z=b;\n  }\n\n  return(z);\n}\n\n\n\n\n\ndouble Like1(arma::vec Y,  //Vector of Toxicity Times\n             arma::vec I,  // Vector of Censoring Indi\n             arma::vec Dose, //Vector of Doses given to Patients\n             arma::vec Group, //Vector of Group Membership, 0 is baseline\n             double mu, // Reference Time\n             double slope, //Baseline Slope for Dose Toxicity Relationship\n             arma::vec a, //Vector of intercepts for non-baseline groups\n             arma::vec b, //vector of slopes for non-baseline groups\n             double T1, // Reference Time\n             int npats //Number of patients currently\n){\n\n  // npats=npats-1;\n  //This may need to be commented out. Not totally sure here.\n\n  double LogL = 0; // Will store likelihood to return\n\n\n  //First we calculate the eta term in the GLM for each patient.\n\n  //Baseline vector\n  arma::vec eta(npats);\n\n  eta.zeros();\n\n  //Needed for For loops\n  int m=0;\n  int k=1;\n\n\n\n\n  for(m=0;m<eta.n_rows;m++){\n    for(k=0;k<a.n_rows;k++){\n      if(Group[m]==(k+1)){\n        eta[m] = a[k]+exp(b[k]+slope)*Dose[m]+mu;\n      }\n    }\n\n    if(Group[m]==0){\n      eta[m]=mu+exp(slope)*Dose[m];\n\n    }\n    //For all groups add the intercept and slope*Groups\n\n\n  }\n\n\n\n  //Now we have the linear predictors in the vector \\eta for all the patients\n  //Now let's compute the likelihood.\n  arma::vec Y1=Y/T1; //Fraction of followup time needed to get the likelihood\n\n\n  for(m=0;m<eta.n_rows;m++){\n    if(I[m]==1){\n      //Not censored so we use the PDF\n      LogL = LogL + eta[m] - log(1+exp(eta[m]));\n\n    }else{\n      LogL = LogL + log(1+(1-Y1[m])*exp(eta[m]))-log(1+exp(eta[m]));\n\n      //      LogL = LogL + log(1-Y1[m]*exp(eta[m])/(1+exp(eta[m])));\n\n\n    }\n\n  }\n\n\n\n\n\n\n\n\n  return(LogL);\n\n\n}\n\n\ndouble LikeMULTI(arma::vec Y,  //Vector of Toxicity Times\n             arma::vec I,  // Vector of Censoring Indi\n             arma::vec Dose, //Vector of Doses given to Patients\n             arma::vec Group, //Vector of Group Membership, 0 is baseline\n             double mu, // Reference Time\n             double slope, //Baseline Slope for Dose Toxicity Relationship\n             arma::vec a, //Vector of intercepts for non-baseline groups\n             arma::vec b, //vector of slopes for non-baseline groups\n             double T1, // Reference Time\n             int npats, //Number of patients currently\n             arma::vec GroupMem1\n){\n\n  // npats=npats-1;\n  //This may need to be commented out. Not totally sure here.\n\n\n\n  arma::vec GroupMem(GroupMem1.n_rows+1);\n\n\n  double LogL = 0; // Will store likelihood to return\n\n\n  //First we calculate the eta term in the GLM for each patient.\n\n  //Baseline vector\n  arma::vec eta(npats);\n\n  eta.zeros();\n\n  //Needed for For loops\n  int m=0;\n  int k=1;\n\n  for(m=1;m<GroupMem.n_rows;m++){\n\n    GroupMem[m]=GroupMem1[m-1];\n\n  }\n\n  GroupMem[0]=0;\n  for(m=0;m<eta.n_rows;m++){\n    for(k=0;k<a.n_rows;k++){\n      if(GroupMem(Group[m])==(k+1)){\n        eta[m] = a[k]+exp(b[k]+slope)*Dose[m]+mu;\n      }\n    }\n\n    if(GroupMem(Group[m])==0){\n      eta[m]=mu+exp(slope)*Dose[m];\n\n    }\n    //For all groups add the intercept and slope*Groups\n\n\n  }\n\n\n\n  //Now we have the linear predictors in the vector \\eta for all the patients\n  //Now let's compute the likelihood.\n  arma::vec Y1=Y/T1; //Fraction of followup time needed to get the likelihood\n\n\n  for(m=0;m<eta.n_rows;m++){\n    if(I[m]==1){\n      //Not censored so we use the PDF\n      LogL = LogL + eta[m] - log(1+exp(eta[m]));\n\n    }else{\n      LogL = LogL + log(1+(1-Y1[m])*exp(eta[m]))-log(1+exp(eta[m]));\n\n      //      LogL = LogL + log(1-Y1[m]*exp(eta[m])/(1+exp(eta[m])));\n\n\n    }\n\n  }\n\n\n\n\n\n\n\n\n  return(LogL);\n\n\n}\n\n\ndouble Like3(arma::vec Y,  //Vector of Toxicity Times\n             arma::vec I,  // Vector of Censoring Indi\n             arma::vec Dose, //Vector of Doses given to Patients\n             arma::vec Group, //Vector of Group Membership, 0 is baseline\n             double mu, // Reference Time\n             double slope, //Baseline Slope for Dose Toxicity Relationship\n             arma::vec a, //Vector of intercepts for non-baseline groups\n             arma::vec b, //vector of slopes for non-baseline groups\n             double T1, // Reference Time\n             int npats, //Number of patients currently\n               int which1 //This is the Group that's dropped\n){\n\n  // npats=npats-1;\n  //This may need to be commented out. Not totally sure here.\n\n  double LogL = 0; // Will store likelihood to return\n\n\n  //First we calculate the eta term in the GLM for each patient.\n\n  //Baseline vector\n  arma::vec eta(npats);\n\n  eta.zeros();\n\n  //Needed for For loops\n  int m=0;\n  int k=1;\n\n\n\nif(which1<0){\n //The Baseline Group was NOT REMOVED\n\n  for(m=0;m<eta.n_rows;m++){\n    for(k=0;k<a.n_rows;k++){\n      if(Group[m]==(k+1)){\n        eta[m] = a[k]+exp(b[k]+slope)*Dose[m]+mu;\n      }\n    }\n\n    if(Group[m]==0){\n      eta[m]=mu+exp(slope)*Dose[m];\n\n    }\n    //For all groups add the intercept and slope*Groups\n\n\n  }\n\n}else{\n  //The Baseline Group (and maybe others) WAS REMOVED\n\n  for(m=0;m<eta.n_rows;m++){\n    for(k=0;k<a.n_rows;k++){\n      if(Group[m]==(k+1)){\n        eta[m] = a[k]+exp(b[k]+slope-b[which1-1])*Dose[m]+mu-a[which1-1];\n      }\n    }\n\n    if(Group[m]==which1){\n      eta[m]=mu+exp(slope)*Dose[m];\n\n    }\n    //For all groups add the intercept and slope*Groups\n\n\n  }\n\n\n\n}\n\n  //Now we have the linear predictors in the vector \\eta for all the patients\n  //Now let's compute the likelihood.\n  arma::vec Y1=Y/T1; //Fraction of followup time needed to get the likelihood\n\n\n  for(m=0;m<eta.n_rows;m++){\n    if(I[m]==1){\n      //Not censored so we use the PDF\n      LogL = LogL + eta[m] - log(1+exp(eta[m]));\n\n    }else{\n      LogL = LogL + log(1+(1-Y1[m])*exp(eta[m]))-log(1+exp(eta[m]));\n\n      //      LogL = LogL + log(1-Y1[m]*exp(eta[m])/(1+exp(eta[m])));\n\n\n    }\n\n  }\n\n\n\n\n\n\n\n\n  return(LogL);\n\n\n}\n\n\n//This is if the trial drops to just 1 subgroup\ndouble Like2(arma::vec Y,  //Vector of Toxicity Times\n             arma::vec I,  // Vector of Censoring Indi\n             arma::vec Dose, //Vector of Doses given to Patients\n             double mu, // Reference Time\n             double slope, //Baseline Slope for Dose Toxicity Relationship\n             double T1, // Reference Time\n             int npats //Number of patients currently\n){\n\n  // npats=npats-1;\n  //This may need to be commented out. Not totally sure here.\n\n  double LogL = 0; // Will store likelihood to return\n\n\n  //First we calculate the eta term in the GLM for each patient.\n\n  //Baseline vector\n  arma::vec eta(npats);\n\n  eta.zeros();\n\n  //Needed for For loops\n  int m=0;\n  int k=1;\n\n\n\n\n  for(m=0;m<eta.n_rows;m++){\n\n      eta[m]=mu+exp(slope)*Dose[m];\n\n\n    //For all groups add the intercept and slope*Groups\n\n\n  }\n\n\n\n  //Now we have the linear predictors in the vector \\eta for all the patients\n  //Now let's compute the likelihood.\n  arma::vec Y1=Y/T1; //Fraction of followup time needed to get the likelihood\n\n\n  for(m=0;m<eta.n_rows;m++){\n    if(I[m]==1){\n      //Not censored so we use the PDF\n      LogL = LogL + eta[m] - log(1+exp(eta[m]));\n\n    }else{\n      LogL = LogL + log(1+(1-Y1[m])*exp(eta[m]))-log(1+exp(eta[m]));\n\n      //      LogL = LogL + log(1-Y1[m]*exp(eta[m])/(1+exp(eta[m])));\n\n\n    }\n\n  }\n\n\n\n\n\n\n\n\n  return(LogL);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint Sample1(int J1){\n\n  arma::vec groupprob(J1);\n\n  double J=J1;\n\n\n\n  int m=0;\n\n  for(m=0;m<J;m++){\n    groupprob[m]=1/J;\n  }\n\n\n\n  arma::vec cumprob=groupprob;\n\n\n\n\n  for(m=1;m<groupprob.n_rows;m++){\n    cumprob[m]=1/J+cumprob[m-1];\n  }\n\n\n  //Now we have the vector of cumulative probabilities, let's draw a random unif\n  double U=as_scalar(arma::randu(1));\n\n  int Which=0;\n\n\n  if(U<cumprob[0]){\n    Which=0;\n  }else{\n\n    for(m=0;m<(groupprob.n_rows-2);m++){\n      if(U>cumprob[m] & U<cumprob[m+1]){\n        Which=m+1;\n      }\n\n    }\n\n    if(U>cumprob[groupprob.n_rows-2]){\n      Which=groupprob.n_rows -1;\n    }\n\n\n  }\n\n\n  return(Which);\n\n}\n\n\n\n\n\nint GetIn(arma::vec INVEC){\n  int k=0;\n\n  arma::vec RetVal(sum(INVEC));\n  int m=0;\n  if(INVEC[0]==1){\n    RetVal[0]=1;\n    //Different Here\n\n    m=1;\n    for(k=1;k<RetVal.n_rows;k++){\n      while(INVEC[m]==0){\n        m++;\n      }\n      RetVal[k]=m;\n      m=m+1;\n\n\n    }\n\n\n\n  }else{\n\n    m=0;\n    for(k=0;k<RetVal.n_rows;k++){\n      while(INVEC[m]==0){\n        m++;\n      }\n      RetVal[k]=m;\n      m=m+1;\n\n\n    }\n\n  }\n\n\n\n\n  //Now Randomly Select One\n\n  return(RetVal(Sample1(RetVal.n_rows)));\n\n\n\n}\n\n\n\n\n\n\nint GetOut(arma::vec INVEC){\n  int k=0;\n\n  arma::vec RetVal(INVEC.n_rows-sum(INVEC));\n  int m=0;\n  if(INVEC[0]==0){\n    RetVal[0]=1;\n    //Different Here\n\n    m=1;\n    for(k=1;k<RetVal.n_rows;k++){\n      while(INVEC[m]==1){\n        m++;\n      }\n      RetVal[k]=m;\n      m=m+1;\n\n\n    }\n\n\n\n  }else{\n\n    m=0;\n    for(k=0;k<RetVal.n_rows;k++){\n      while(INVEC[m]==1){\n        m++;\n      }\n      RetVal[k]=m;\n      m=m+1;\n\n\n    }\n\n  }\n\n\n\n\n  //Now Randomly Select One\n\n  return(RetVal(Sample1(RetVal.n_rows)));\n\n\n\n}\n\n\n\n\n\nint GetNewGroup(arma::vec INVEC){\n\n  double J1 = sum(INVEC);\n  int J=sum(INVEC);\n  double prob = 1/(J1+1);\n\n  int m=0;\n  int k=0;\n  arma::vec cumprob(J+1);\n\n  cumprob.zeros();\n  cumprob[0]=prob;\n\n\n  //Fill in w probs\n  for(m=1;m<cumprob.n_rows;m++){\n    cumprob[m]=prob+cumprob[m-1];\n  }\n\n\n  //Now we have the vector of cumulative probabilities, let's draw a random unif\n  double U=as_scalar(arma::randu(1));\n\n  int Which=0;\n\n\n  if(U<cumprob[0]){\n    Which=0;\n  }else{\n\n    for(m=0;m<(cumprob.n_rows-2);m++){\n      if(U>cumprob[m] & U<cumprob[m+1]){\n        Which=m+1;\n      }\n\n    }\n\n    if(U>cumprob[cumprob.n_rows-2]){\n      Which=cumprob.n_rows -1;\n    }\n\n\n  }\n\n\n  //Now Which Contains the entry that we are going to combine into:\n\n  if(Which==0){\n    return(0);\n  }else{\n    arma::vec entries(J);\n\n    k=0;\n    for(m=0;m<J;m++){\n\n      while(INVEC[k]==0){\n        k++;\n      }\n      entries(m)=k;\n      k=k+1;\n\n\n\n    }\n\n    entries=entries+1;\n\n    return(entries(Which-1));\n\n  }\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//[[Rcpp::export]]\nList SimTrial1(int nSims, //Number of Simulations to Run\n               int Nmax, //Max patients to enroll in trial\n               double  T1, //Reference Time\n               arma::vec Target, //Reference Probability Target (or vector)\n               arma::vec Dose, //Standardized Vector of Doses\n               arma::vec DoseStart, //Vector (or just one) Starting Dose Level\n               arma::vec Upper, //Thresholds for subgroup suspension\n               double Accrue, //Expected Monthly accrual rate\n               arma::vec groupprob, //Subgroup Enrollment Probabilities\n               int Family, //Indicator of Distribution family to simulate from. Alphabetical order\n               arma::mat Param1, //Group Specific Parameter matrix for each dose and subgroup to simulate from\n               arma::mat Param2,\n               double meanmu, //Prior mean of intercept\n               double meanslope, //Prior mean of slope\n               arma::vec MeanInts, //Prior means of group intercepts\n               arma::vec MeanSlopes,\n               double varint,\n               double varbeta){\n\n  int g=0;\n\n  //Change this to be an input\n  arma::vec PROBIN(Param1.n_rows-1);\n  for(g=0;g<PROBIN.n_rows;g++){\n    PROBIN(g)=.9;\n  }\n\n  int MEANS=0;\n\n  int IntIN=0;\n  int IntOUT=0;\n\n  //Group Slope Prior Var\n  double varbeta1=varbeta;\n  //Group Int Prior Var\n  double varint1=varint;\n\n\n\n  int Group=0;\n  //Important For loop integer\n  int m =0; //For the inner MCMC looprep\n  int i=0; //For the patient index\n  int rep=0; //For the simulation repetition.\n\n\n  //First Fill out Target Vector\n  int nDose=Dose.n_rows;\n\n\n  //Important Integer Quantities\n  int B=2000; //Number of iterations for MCMC\n\n\n  int B1=B/2;\n\n  //Make List objects we'll use\n\n  //Trial Vectors\n  arma::vec Y(Nmax);\n  arma::vec I(Nmax);\n  arma::vec Groups(Nmax);\n  arma::vec Doses(Nmax);\n  arma::vec Times(Nmax);\n  arma::vec ACC(Nmax);\n\n\n  //Innitialize parameters for MCMC\n  double mu=meanmu;\n  double slope=meanslope;\n  double sig=T1;\n\n  double NewMean=0;\n  double NewSlope=0;\n  int Which1=0;\n\n\n\n  //Important quantities we will need in the MCMC\n  int  J=MeanInts.n_rows;\n  double alpha=0;\n  double U=0;\n  double signew=0;\n  double slopenew=0;\n  double Munew=0;\n\n  //For loop integers\n  int j=0;\n  int k=0;\n\n\n  //Check to see if Dosestart = 0 otherwise rearrange for c++\n  DoseStart=DoseStart-1;\n\n\n  int StoreInx=0;\n  //Vector Of group intercepts\n  arma::vec a(J);\n  //Vector of group slopes\n  arma::vec b=a;\n  //Vectors for Group MCMC\n\n\n\n  //Vectors for proposals\n  arma::vec aprop = a;\n  arma::vec bprop=b;\n\n\n\n\n\n  arma::vec NumA(J);\n  arma::vec NumB(J);\n  arma::vec IntA(J);\n  arma::vec IntB(J);\n\n  double NumMu = 2;\n  double NumSlope=2;\n  double IntMu=1;\n  double IntSlope=1;\n\n  arma::vec avar(J);\n  arma::vec bvar(J);\n\n\n  double muvar=1;\n  double slopevar=1;\n  double trialtime=0;\n  NumericVector z9(2);\n  NumericVector zprop(5);\n\n  double NumSig=2;\n  double IntSig=1;\n  double sigvar=1;\n\n  arma::vec etaG(J+1);\n  arma::mat DoseProb(B1,(J+1)*nDose);\n  arma::mat MeanDose(J+1,nDose);\n  arma::vec sigstore(B1);\n  arma::vec mustore(B1);\n  arma::vec slopestore(B1);\n  arma::mat astore(B1,J);\n  arma::mat bstore=astore;\n  double eta1=0;\n  double DEC=0;\n\n  arma::vec GroupMem(J);\n  arma::vec GroupMemProp=GroupMem;\n\n  arma::vec INVEC(J);\n  INVEC.zeros();\n\n  int eta2=0;\n\n  arma::mat MeanVec((J+1),nDose);\n  arma::vec NTox(J+1);\n  arma::vec OptDose(J+1);\n  arma::vec StoppedGroups(J+1);\n  arma::vec SuspendGroups(J+1);\n  arma::vec GLast(J+1);\n  arma::vec nTreated(J+1);\n  double stopped=0;\n  arma::vec TrialTimes(nSims);\n  arma::mat OptimalDoses(nSims,(J+1));\n  arma::mat NTOX = OptimalDoses;\n  arma::vec GroupVec(nDose);\n  arma::vec TriedGroups(J+1);\n\n\n\n  arma::mat DoseStore(nSims,Nmax);\n  arma::mat GroupStore(nSims,Nmax);\n  arma::mat DoseTried((J+1),nDose);\n  arma::vec nTreated1(J+1);\n  nTreated1.zeros();\nINVEC.zeros();\n\narma::vec INVECNEW=INVEC;\narma::vec Y2;\narma::vec I2;\narma::vec Groups2;\narma::vec Doses2;\narma::vec GetGroup=StoppedGroups;\n\n\nif(Param1.n_rows==2){\n//Two Subgroups\n\n  //Wrap nreps around\n  for(rep=0;rep<nSims;rep++){\n\n\n\n\n    if(rep%100==0){\n\n      Rf_PrintValue(wrap(rep));\n\n      Rprintf(\"Simulations Finished\");\n\n    }\n\n    //Wrap i around\n\n    MeanVec.zeros();\n    //Reset all trial vectors\n    trialtime=0;\n    stopped=0;\n    OptDose.zeros();\n    StoppedGroups.zeros();\n    SuspendGroups.zeros();\n    TriedGroups.zeros();\n    Y.zeros();\n    I.zeros();\n    Times.zeros();\n    ACC.zeros();\n    Groups.zeros();\n    Doses.zeros();\n    GLast.zeros()+10000;\n    nTreated.zeros();\n    DoseTried.zeros();\n\n    NTox.zeros();\n\n\n\n\n    //Enroll the first patient\n\n    Group=Sample2(groupprob);\n\n    Groups[0]=Group;\n\n    Doses[0]=Dose[DoseStart[Group]];\n\n    nTreated[Group]=nTreated[Group]+1;\n\n    ACC[0]=0;\n\n    if(Family==0){\n      Times(0)=R::rexp(Param1(Group,DoseStart[Group]));\n    }\n\n\n\n    if(Family==1){\n      Times[0]=R::rgamma(Param1(Group,DoseStart[Group]),1/Param2(Group,DoseStart[Group]));\n    }\n\n    if(Family==2){\n      Times[0]=R::rlnorm(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n    }\n\n\n    if(Family==3){\n      if(as_scalar(arma::randu(1))<Param1(Group,DoseStart[Group])){\n        Times[0]=as_scalar(arma::randu(1))*T1;\n      }else{\n        Times[0]=T1+1;\n      }\n    }\n\n    if(Family==4){\n      Times[0]=R::rweibull(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n    }\n\n    DoseTried(Group,DoseStart(Group))=1;\n\n\n    if(DoseStart[Group]==0){\n      nTreated1[Group]=nTreated1[Group]+1;\n    }\n\n    for(i=1;i<Nmax;i++){\n      //Start the Trial, Let's do this\n\n      trialtime=trialtime+R::rexp(1/Accrue);\n      Group=Sample2(groupprob);\n\n      DEC=0;\n\n\n      //Now its not in a stopped group or a subgroup so let's do our MCMC\n\n\n\n\n\n      //Enrolling in a new subgroup\n      if(TriedGroups[Group]==0){\n\n        nTreated[Group]=nTreated[Group]+1;\n\n        if(DoseStart[Group]==0){\n          nTreated1[Group]=nTreated1[Group]+1;\n        }\n\n        Groups[i]=Group;\n\n        Doses[i]=Dose[DoseStart[Group]];\n\n        ACC[i]=trialtime;\n\n        if(Family==0){\n          Times(i)=R::rexp(Param1(Group,DoseStart[Group]));\n        }\n\n\n\n        if(Family==1){\n          Times[i]=R::rgamma(Param1(Group,DoseStart[Group]),1/Param2(Group,DoseStart[Group]));\n        }\n\n        if(Family==2){\n          Times[i]=R::rlnorm(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n        }\n\n\n        if(Family==3){\n          if(as_scalar(arma::randu(1))<Param1(Group,DoseStart[Group])){\n            Times[i]=as_scalar(arma::randu(1))*T1;\n          }else{\n            Times[i]=T1+1;\n          }\n        }\n\n        if(Family==4){\n          Times[i]=R::rweibull(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n        }\n\n\n        DoseTried(Group,DoseStart(Group))=1;\n        TriedGroups[Group]=1;\n\n      }else{\n        //Not in a new subgroup, let's do our MCMC\n\n        DEC=0;\n\n        while(DEC==0){\n          //If this patient group is\n\n          I.zeros();\n          Y.zeros();\n\n          //Setup Y\n          for(k=0;k<i;k++){\n            Y[k]=min1(min1(Times[k],trialtime-ACC[k]),T1);\n            if(Times[k]==Y[k]){\n              I[k]=1;\n            }\n          }\n\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=meanmu;\n          slope=meanslope;\n   INVEC.zeros();\n   INVECNEW.zeros();\n   INVEC = INVEC+1;\n   a=MeanInts;\n   b=MeanSlopes;\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n                for(k=0;k<(J+1);k++){\n                  if((IntA[k]/NumA[k])>.5){\n                    avar[k]=avar[k]*2;\n                  }\n\n                  if((IntA[k]/NumA[k])<.2){\n                    avar[k]=avar[k]/2;\n                  }\n\n\n\n\n\n\n\n\n                  if((IntB[k]/NumB[k])>.5){\n                    bvar[k]=bvar[k]*2;\n                  }\n\n                  if((IntB[k]/NumB[k])<.2){\n                    bvar[k]=bvar[k]/2;\n                  }\n\n\n\n                }\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n                NumA=NumA.zeros()+2;\n                NumB=NumB.zeros()+2;\n                IntA=IntA.zeros()+1;\n                IntB=IntB.zeros()+1;\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n            for(k=0;k<aprop.n_rows;k++){\n\n              if(INVEC[k]>0){\n\n              aprop=a;\n              aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n              alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n\n              if(U<alpha){\n                a(k)=aprop(k);\n                IntA[k]=IntA[k]+1;\n              }\n\n              NumA=NumA+1;\n\n\n              }\n            }\n            //Now do a MH step for the slope\n\n            for(k=0;k<aprop.size();k++){\n\n              if(INVEC[k]>0){\n              bprop=b;\n              bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n              alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  Like1(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n              z9[0]=alpha;\n\n              //  Rf_PrintValue(wrap(z9));\n\n              if(U<alpha){\n                b[k]=bprop[k];\n                IntB[k]=IntB[k]+1;\n              }\n\n              }\n\n            }\n\n\n            NumB=NumB+1;\n\n\n\n            //Spike And Slab\n\n            for(k=0;k<J;k++){\n              if(INVEC[k]==0){\n                //ADD Move\n          aprop[k]=as_scalar(arma::randn(1))/10;\n          bprop[k]=as_scalar(arma::randn(1))/10;\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n                alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n                U=log(as_scalar(arma::randu(1)));\n\n                z9[0]=alpha;\n\n                //  Rf_PrintValue(wrap(z9));\n\n                if(U<alpha){\n                  b[k]=bprop[k];\n                  a[k]=aprop[k];\n                  INVEC[k]=1;\n                }\n\n\n              }else{\n                //Delete Move\n\n                //Delete Move\n                aprop[k]=0;\n                bprop[k]=0;\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n                alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                if(U<alpha){\n                  b[k]=0;\n                  a[k]=0;\n                  INVEC[k]=0;\n                }\n\n\n              }\n\n\n\n\n\n\n\n            }\n\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   Like1(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n            alpha =   alpha+  Like1(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n              for(j=0;j<J;j++){;\n                astore(StoreInx,j)=a(j);\n                bstore(StoreInx,j)=b[j];\n              }\n\n              mustore[StoreInx]=mu;\n              slopestore[StoreInx]=slope;\n              sigstore[StoreInx]=sig;\n\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n\n              for(k=0;k<(J+1);k++){\n\n                for(j=0;j<nDose;j++){\n                  eta1=0;\n\n                  if(k>0){\n                    eta1 = a[k-1]+exp(b[k-1]+slope)*Dose[j]+mu;\n                  }\n\n                  if(k==0){\n                    eta1=mu+exp(slope)*Dose[j];\n\n                  }\n\n                  //For all groups add the intercept and slope*Groups\n\n                  eta1=exp(eta1);\n\n                  if(eta1>100000){\n                    DoseProb(StoreInx, k*nDose+j) = 1;\n\n                  }else{\n                    DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                  }\n\n\n\n                }\n\n\n              }\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n          }\n\n\n\n          StoppedGroups.zeros();\n\n          //Do we have a stopped group?\n          for(k=0;k<(J+1);k++){\n            eta2=0;\n\n            for(j=0;j<DoseProb.n_rows;j++){\n              //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n              if(DoseProb(j,k*nDose)>Target[k]){\n                eta2++;\n              }\n\n\n            }\n\n\n\n            if(eta2>(Upper[k]*DoseProb.n_rows)){\n              StoppedGroups[k]=1;\n            }\n\n          }\n\n\n\n\n          //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n          for(k=0;k<(J+1);k++){\n            if(nTreated1[k]<3){\n              StoppedGroups[k]=0;\n            }\n\n            if(nTreated1[k]>2){\n              GetGroup.zeros();\n              GetGroup[k]=1;\n\n              Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n              I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n              if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n                StoppedGroups[k]=0;\n              }\n\n            }\n\n\n          }\n\n\n\n\n\n\n          //    Rf_PrintValue(wrap(StoppedGroups));\n          if(sum(StoppedGroups)==(J+1)){\n            //Let's try the groups separately to make sure we aren't stopping unneccessarily\n          StoppedGroups.zeros();\n\n          for(g=0;g<(J+1);g++){\n            GetGroup.zeros();\n            GetGroup[g]=1;\n\n            Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n            I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n            Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n        Which1 = g;\n\n\n            if(Which1==0){\n              NewMean = meanmu;\n              NewSlope=meanslope;\n            }else{\n              NewMean = meanmu+MeanInts[Which1-1];\n              NewSlope=meanslope+MeanSlopes[Which1-1];\n            }\n\n\n\n\n\n            //Inner MCMC loop, only compute neccessary quantities. Reset counters\n            NumA=NumA.zeros()+2;\n            NumB=NumB.zeros()+2;\n            IntA=IntA.zeros()+1;\n            IntB = IntB.zeros()+1;\n            NumMu = 2;\n            NumSlope=2;\n            IntMu=1;\n            IntSlope=1;\n            avar=avar.zeros()+1;\n            bvar=bvar.zeros()+1;\n            muvar=1;\n            slopevar=1;\n            NumSig=2;\n            IntSig=1;\n            sigvar=1;\n            a.zeros();\n            b.zeros();\n            MeanVec.zeros();\n            GroupVec.zeros();\n            mu=NewMean;\n            slope=NewSlope;\n\n\n            for(m=0;m<B;m++){\n\n              if(m<(B/2 + 2)){\n                if(m%100==0){\n\n\n\n\n                  if((IntMu/NumMu)>.5){\n                    muvar=muvar*2;\n                  }\n\n                  if((IntMu/NumMu)<.2){\n                    muvar=muvar/2;\n                  }\n\n\n                  if((IntSlope/NumSlope)>.5){\n                    slopevar=slopevar*2;\n                  }\n\n                  if((IntSlope/NumSlope)<.2){\n                    slopevar=slopevar/2;\n                  }\n\n\n\n\n\n\n\n                  NumMu = 2;\n                  NumSlope=2;\n                  IntMu=1;\n                  IntSlope=1;\n                  IntSig=1;\n                  NumSig=2;\n\n\n\n\n                }\n              }\n\n\n\n\n\n\n\n\n\n              Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n              alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n              if(U<alpha){\n                mu=Munew;\n                IntMu=IntMu+1;\n              }\n\n              NumMu=NumMu+1;\n\n\n\n\n              //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n              slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n              //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n              //Proposal ratio for beta\n\n              alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n              alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n              if(U<alpha){\n                slope=slopenew;\n                IntSlope=IntSlope+1;\n              }\n              NumSlope=NumSlope+1;\n\n\n\n\n\n              if(m>(B-B1-1)){\n                //Make OptDose and StoppedGroups\n                StoreInx=m-B1;\n\n\n\n                //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n                //First nDose\n\n\n                k=Which1;\n\n                for(j=0;j<nDose;j++){\n                  eta1=0;\n\n\n\n\n                  eta1=mu+exp(slope)*Dose[j];\n\n\n\n                  //For all groups add the intercept and slope*Groups\n\n                  eta1=exp(eta1);\n\n                  if(eta1>100000){\n                    DoseProb(StoreInx, k*nDose+j) = 1;\n\n                  }else{\n                    DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                  }\n\n\n\n                }\n\n\n\n                //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n              }\n\n              //End MCMC\n            }\n            //Is our very last group stopped?\n\n            k=Which1;\n            eta2=0;\n\n            for(j=0;j<DoseProb.n_rows;j++){\n              //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n              if(DoseProb(j,k*nDose)>Target[k]){\n                eta2++;\n              }\n\n\n            }\n\n\n            if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n              StoppedGroups[Which1]=1;\n            }\n\n\n\n\n\n\n          }\n\n\n\n\n\n          }\n\n\n\n\n          //Should we stop the trial?\n          if(sum(StoppedGroups)==(J+1)){\n            stopped=1;\n            break;\n          }\n\n\n\n\n\n\n\n\n\n          if(StoppedGroups[Group]==0){\n            //Enroll this patient\n            DEC=1;\n\n\n            if(sum(StoppedGroups)>0){\n              //If we have a stopped group, REMOVE IT\n\n              Y2=ReturnStoppedY(Y,I,Groups,StoppedGroups,i);\n              I2=ReturnStoppedI(Y,I,Groups,StoppedGroups,i);\n              Groups2=ReturnStoppedGroups(Y,I,Groups,StoppedGroups,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,StoppedGroups,i);\n\n\n\n\n\n\n\n\n          //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n          for(k=0;k<(J+1);k++){\n            if(nTreated1[k]<3){\n              StoppedGroups[k]=0;\n            }\n\n            if(nTreated1[k]>2){\n              GetGroup.zeros();\n              GetGroup[k]=1;\n\n              Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n              I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n              if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n                StoppedGroups[k]=0;\n              }\n\n            }\n\n\n          }\n\n\n\n\n\n          if(sum(StoppedGroups)==(J+1)){\n            stopped=1;\n\n            Rf_PrintValue(wrap(StoppedGroups));\n            Rprintf(\"It Stopped\");\n\n            Rf_PrintValue(wrap(Y2));\n            Rf_PrintValue(wrap(I2));\n            Rf_PrintValue(wrap(Doses2));\n\n\n            break;\n          }\n\n\n\n\n            }\n\n\n\n\n\n          }else{\n\n            trialtime=trialtime+R::rexp(1/Accrue);\n            Group=Sample2(groupprob);\n\n          }\n\n//Do We have ANOTHER STOPPED GROUP?\n//Should we stop the trial?\n\n\n\n\n\n\n\nif(sum(StoppedGroups)==(J+1)){\n  stopped=1;\n\n  Rf_PrintValue(wrap(StoppedGroups));\n  Rprintf(\"It Stopped\");\n\n  Rf_PrintValue(wrap(Y2));\n  Rf_PrintValue(wrap(I2));\n  Rf_PrintValue(wrap(Doses2));\n\n\n  break;\n}\n\n\n        }\n\n        //Ok now let's enroll this patient, Whats the Optimal Dose\n\n        //If Stopped==1, Get out of the trial\n        if(stopped==1){\n          break;\n        }\n\n\n\n        if(MEANS==0){\n          for(k=0;k<(J+1);k++){\n            for(j=0;j<nDose;j++){\n              MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n            }\n\n          }\n\n\n\n        }\n\n\n        //Determine Optimal Dose\n          k=Group;\n          eta1=MinVec(abs(MeanVec.row(k).t()-Target(k)));\n          j=0;\n\n\n\n\n          GroupVec = abs(MeanVec.row(k).t()-Target(k));\n\n          while(GroupVec[j]!=eta1 ){\n            j++;\n            //Loop Proceeds until the minimum difference is reached\n          }\n\n          OptDose[k]=j;\n\n\n\n\n        //Now we have the subgroup specific optimal doses in the vector OptDose\n\n\n\n        //Now let's see if the dose is bigger than the largest dose.\n        if(OptDose[Group]>=nDose){\n          OptDose[Group]=nDose-1;\n        }\n\n\n\n        //Is this dose bigger than the dose higher than what's been tried?\n        if(DoseTried(Group,OptDose[Group])==0){\n          j=0;\n\n          while(DoseTried(Group,j)==1){\n            j++;\n          }\n\n          OptDose[Group]=j;\n\n        }\n\n\n\n\n\n\n        //Assign Patient to subgroup, optdose, add accrual time.\n\n        Groups[i]=Group;\n        if(OptDose[Group]==0){\n          //If we assign one at the lowest dose add this\n          nTreated1[Group]=nTreated1[Group]+1;\n        }\n        nTreated[Group]=nTreated[Group]+1;\n\n        //If this is the 3rd patient treated in this subgroup with the lowest dose, suspend accrual for TGroup\n        if(nTreated[Group]==3){\n          SuspendGroups[Group]=1;\n          GLast[Group]=trialtime;\n        }\n\n\n\n        Doses[i]=Dose[OptDose[Group]];\n\n\n        ACC[i]=trialtime;\n        //Based on the Group and Optimal dose, randomly generate the next patient Data\n\n\n        if(Family==0){\n          Times(i)=R::rexp(Param1(Group,OptDose[Group]));\n        }\n\n\n\n        if(Family==1){\n          Times[i]=R::rgamma(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n        if(Family==2){\n          Times[i]=R::rlnorm(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n\n        if(Family==3){\n          if(as_scalar(arma::randu(1))<Param1(Group,OptDose[Group])){\n            Times[i]=as_scalar(arma::randu(1))*T1;\n          }else{\n            Times[i]=T1+1;\n          }\n        }\n\n        if(Family==4){\n          Times[i]=R::rweibull(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n\n        DoseTried(Group,OptDose(Group))=1;\n\n\n\n\n\n\n\n\n\n\n\n\n      }\n\n\n\n\n      //End of the i loop, now we have ALL the patients\n    }\n\n\n\n    //Now let's make the final decision.\n    if(stopped==1){\n      //The trial Ended Early, i-1 is the index of the last patient enrolled.\n\n\n      for(k=0;k<i;k++){\n        for(j=0;j<(J+1);j++){\n          if(Groups[k]==j){\n            NTox[j]=NTox[j]+I[k];\n          }\n        }\n      }\n\n\n      //All Optimal Doses are -1\n      for(k=0;k<(J+1);k++){\n        OptDose[k]=-1;\n      }\n\n\n    }else{\n      //The trial did NOT end early. Follow patients out until end of trial and get the optimal doses\n      trialtime=trialtime+T1;\n\n\n\n      Y.zeros();\n      I.zeros();\n\n      //Setup Y\n      for(k=0;k<Nmax;k++){\n\n        Y[k]=min1(Times[k],T1);\n\n\n        if(Times[k]<T1){\n          I[k]=1;\n        }\n      }\n\n\n\n\n\n      //Inner MCMC loop, only compute neccessary quantities. Reset counters\n      NumA=NumA.zeros()+2;\n      NumB=NumB.zeros()+2;\n      IntA=IntA.zeros()+1;\n      IntB = IntB.zeros()+1;\n      NumMu = 2;\n      NumSlope=2;\n      IntMu=1;\n      IntSlope=1;\n      avar=avar.zeros()+1;\n      bvar=bvar.zeros()+1;\n      muvar=1;\n      slopevar=1;\n      NumSig=2;\n      IntSig=1;\n      sigvar=1;\n      a.zeros();\n      b.zeros();\n      MeanVec.zeros();\n      GroupVec.zeros();\n      mu=meanmu;\n      slope=meanslope;\nINVEC.zeros();\nINVEC = INVEC+1;\na=MeanInts;\nb=MeanSlopes;\n\n      for(m=0;m<B;m++){\n\n        if(m<(B/2 + 2)){\n          if(m%100==0){\n\n\n            for(k=0;k<(J+1);k++){\n              if((IntA[k]/NumA[k])>.5){\n                avar[k]=avar[k]*2;\n              }\n\n              if((IntA[k]/NumA[k])<.2){\n                avar[k]=avar[k]/2;\n              }\n\n\n\n\n\n\n\n\n              if((IntB[k]/NumB[k])>.5){\n                bvar[k]=bvar[k]*2;\n              }\n\n              if((IntB[k]/NumB[k])<.2){\n                bvar[k]=bvar[k]/2;\n              }\n\n\n\n            }\n\n\n            if((IntMu/NumMu)>.5){\n              muvar=muvar*2;\n            }\n\n            if((IntMu/NumMu)<.2){\n              muvar=muvar/2;\n            }\n\n\n            if((IntSlope/NumSlope)>.5){\n              slopevar=slopevar*2;\n            }\n\n            if((IntSlope/NumSlope)<.2){\n              slopevar=slopevar/2;\n            }\n\n\n\n\n\n            NumA=NumA.zeros()+2;\n            NumB=NumB.zeros()+2;\n            IntA=IntA.zeros()+1;\n            IntB=IntB.zeros()+1;\n\n            NumMu = 2;\n            NumSlope=2;\n            IntMu=1;\n            IntSlope=1;\n            IntSig=1;\n            NumSig=2;\n\n\n\n\n          }\n        }\n\n\n\n        for(k=0;k<aprop.n_rows;k++){\n\n          if(INVEC[k]>0){\n\n            aprop=a;\n            aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n            alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n            if(U<alpha){\n              a(k)=aprop(k);\n              IntA[k]=IntA[k]+1;\n            }\n\n            NumA=NumA+1;\n\n\n          }\n        }\n        //Now do a MH step for the slope\n\n        for(k=0;k<aprop.size();k++){\n\n          if(INVEC[k]>0){\n            bprop=b;\n            bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n            alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  Like1(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            z9[0]=alpha;\n\n            //  Rf_PrintValue(wrap(z9));\n\n            if(U<alpha){\n              b[k]=bprop[k];\n              IntB[k]=IntB[k]+1;\n            }\n\n          }\n\n        }\n\n\n        NumB=NumB+1;\n\n\n\n        //Spike And Slab\n\n        for(k=0;k<J;k++){\n          if(INVEC[k]==0){\n            //ADD Move\n            aprop[k]=as_scalar(arma::randn(1))/10;\n            bprop[k]=as_scalar(arma::randn(1))/10;\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n            alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n            U=log(as_scalar(arma::randu(1)));\n\n            z9[0]=alpha;\n\n            //  Rf_PrintValue(wrap(z9));\n\n            if(U<alpha){\n              b[k]=bprop[k];\n              a[k]=aprop[k];\n              INVEC[k]=1;\n            }\n\n\n          }else{\n            //Delete Move\n\n            //Delete Move\n            aprop[k]=0;\n            bprop[k]=0;\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n            alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            if(U<alpha){\n              b[k]=0;\n              a[k]=0;\n            }\n\n\n          }\n\n\n\n\n\n\n\n        }\n\n\n\n\n\n\n\n        Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n        alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   Like1(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n        if(U<alpha){\n          mu=Munew;\n          IntMu=IntMu+1;\n        }\n\n        NumMu=NumMu+1;\n\n\n\n\n        //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n        slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n        //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n        //Proposal ratio for beta\n\n        alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n        alpha =   alpha+  Like1(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n        if(U<alpha){\n          slope=slopenew;\n          IntSlope=IntSlope+1;\n        }\n        NumSlope=NumSlope+1;\n\n\n\n\n\n        if(m>(B-B1-1)){\n          //Make OptDose and StoppedGroups\n          StoreInx=m-B1;\n\n          for(j=0;j<J;j++){;\n            astore(StoreInx,j)=a(j);\n            bstore(StoreInx,j)=b[j];\n          }\n\n          mustore[StoreInx]=mu;\n          slopestore[StoreInx]=slope;\n          sigstore[StoreInx]=sig;\n\n\n          //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n          //First nDose\n\n\n          for(k=0;k<(J+1);k++){\n\n            for(j=0;j<nDose;j++){\n              eta1=0;\n\n              if(k>0){\n                eta1 = a[k-1]+exp(b[k-1]+slope)*Dose[j]+mu;\n              }\n\n              if(k==0){\n                eta1=mu+exp(slope)*Dose[j];\n\n              }\n\n              //For all groups add the intercept and slope*Groups\n\n              eta1=exp(eta1);\n\n              if(eta1>100000){\n                DoseProb(StoreInx, k*nDose+j) = 1;\n\n              }else{\n                DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n              }\n\n\n\n            }\n\n\n          }\n          //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n        }\n\n        //End MCMC\n      }\n\n\n\n      //Get Optimal Dose\n\n\n      StoppedGroups.zeros();\n      //Get MeanVec\n      //reset to means\n\n\n\n\n      //Now we have the mean vector\n\n\n\n      //Do we have a stopped group?\n      for(k=0;k<(J+1);k++){\n        eta2=0;\n\n        for(j=0;j<DoseProb.n_rows;j++){\n          //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n          if(DoseProb(j,k*nDose)>Target[k]){\n            eta2++;\n          }\n\n\n        }\n\n\n\n\n\n\n\n        if(eta2>(Upper[k]*DoseProb.n_rows)){\n          StoppedGroups[k]=1;\n        }\n\n      }\n\n\n\n\n\n\n    if(sum(StoppedGroups)>0){\n      //If we have a stopped group, REMOVE IT\n\n      Y2=ReturnStoppedY(Y,I,Groups,StoppedGroups,i);\n      I2=ReturnStoppedI(Y,I,Groups,StoppedGroups,i);\n      Groups2=ReturnStoppedGroups(Y,I,Groups,StoppedGroups,i);\n      Doses2=ReturnStoppedY(Doses,I,Groups,StoppedGroups,i);\n\n\n\n\n\n\n\n\n\n      //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n\n      //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n      for(k=0;k<(J+1);k++){\n        if(nTreated1[k]<3){\n          StoppedGroups[k]=0;\n        }\n\n        if(nTreated1[k]>2){\n        GetGroup.zeros();\n        GetGroup[k]=1;\n\n        Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n        I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n        Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n        if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n          StoppedGroups[k]=0;\n        }\n\n        }\n\n\n      }\n\n\n\n\n      //If all groups are stopped, let's do separate trials JUST TO MAKE SURE ONE GROUP IS NOT DOMINATING THE DECISION TO STOP!!\n\n\n      //    Rf_PrintValue(wrap(StoppedGroups));\n      if(sum(StoppedGroups)==(J+1)){\n        //Let's try the groups separately to make sure we aren't stopping unneccessarily\n        StoppedGroups.zeros();\n\n        for(g=0;g<(J+1);g++){\n          GetGroup.zeros();\n          GetGroup[g]=1;\n\n          Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n          I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n          Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n          Which1 = g;\n\n\n          if(Which1==0){\n            NewMean = meanmu;\n            NewSlope=meanslope;\n          }else{\n            NewMean = meanmu+MeanInts[Which1-1];\n            NewSlope=meanslope+MeanSlopes[Which1-1];\n          }\n\n\n\n\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=NewMean;\n          slope=NewSlope;\n\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n            alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n\n              k=Which1;\n\n              for(j=0;j<nDose;j++){\n                eta1=0;\n\n\n\n\n                eta1=mu+exp(slope)*Dose[j];\n\n\n\n                //For all groups add the intercept and slope*Groups\n\n                eta1=exp(eta1);\n\n                if(eta1>100000){\n                  DoseProb(StoreInx, k*nDose+j) = 1;\n\n                }else{\n                  DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                }\n\n\n\n              }\n\n\n\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n          }\n          //Is our very last group stopped?\n\n          k=Which1;\n          eta2=0;\n\n          for(j=0;j<DoseProb.n_rows;j++){\n            //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n            if(DoseProb(j,k*nDose)>Target[k]){\n              eta2++;\n            }\n\n\n          }\n\n\n          if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n            StoppedGroups[Which1]=1;\n          }\n\n\n\n\n\n\n        }\n\n\n\n\n\n      }\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n      if(MEANS==0){\n        for(k=0;k<(J+1);k++){\n          for(j=0;j<nDose;j++){\n            MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n          }\n\n        }\n\n\n\n      }\n\n\n\n\n      //Determine Optimal Doses\n      for(k=0;k<(J+1);k++){\n\n        if(StoppedGroups(k)==1){\n          OptDose(k)=-1;\n        }else{\n          eta1=MinVec(abs(MeanVec.row(k).t()-Target[k]));\n          j=0;\n\n          GroupVec = abs(MeanVec.row(k).t()-Target[k]);\n\n          //  Rf_PrintValue(wrap(MeanVec));\n\n\n          while(GroupVec[j]!=eta1 ){\n            j++;\n            //Loop Proceeds until the minimum difference is reached\n          }\n\n          OptDose[k]=j;\n        }\n\n\n      }\n\n\n\n\n      //Is this dose bigger than the dose higher than what's been tried?\n      for(k=0;k<(J+1);k++){\n        if(StoppedGroups[k]==0){\n          for(j=0;j<(J+1);j++){\n            if(OptDose[j]>=nDose){\n              OptDose[j]=nDose-1;\n            }\n          }\n\n\n\n\n        }\n\n\n\n      }\n\n      //Is this dose bigger than the dose higher than what's been tried?\n      for(k=0;k<(J+1);k++){\n        if(StoppedGroups(k)==0){\n          if(DoseTried(k,OptDose[k])==0){\n            j=0;\n\n            while(DoseTried(k,j)==1){\n              j++;\n            }\n\n            OptDose[k]=j;\n\n          }\n        }\n      }\n\n\n\n\n\n\n      //Num Toxicities\n      for(k=0;k<Nmax;k++){\n        for(j=0;j<(J+1);j++){\n          if(Groups[k]==j){\n            NTox[j]=NTox[j]+I[k];\n          }\n        }\n      }\n\n\n    }\n\n    OptDose=OptDose+1;\n\n\n    TrialTimes(rep)=trialtime;\n    for(j=0;j<(J+1);j++){\n      OptimalDoses(rep,j)=OptDose(j);\n      NTOX(rep,j)=NTox(j);\n    }\n\n\n\n\n    //Fill in Doses and Groups Treated\n    for(j=0;j<Nmax;j++){\n      DoseStore(rep,j)=Doses(j);\n      GroupStore(rep,j)=Groups(j);\n    }\n\n\n\n\n    //End Trial\n  }\n}else{\n  //More than Two Subgroups\n\n\n  arma::vec INVEC(J);\n  INVEC.zeros();\n\n   eta2=0;\n\n  arma::mat MeanVec((J+1),nDose);\n  arma::vec NTox(J+1);\n  arma::vec OptDose(J+1);\n  arma::vec StoppedGroups(J+1);\n  arma::vec SuspendGroups(J+1);\n  arma::vec GLast(J+1);\n  arma::vec nTreated(J+1);\n   stopped=0;\n  arma::vec TrialTimes(nSims);\n  arma::mat OptimalDoses(nSims,(J+1));\n  arma::mat NTOX = OptimalDoses;\n  arma::vec GroupVec(nDose);\n  arma::vec TriedGroups(J+1);\n\n\n\n  arma::mat DoseStore(nSims,Nmax);\n  arma::mat GroupStore(nSims,Nmax);\n  arma::mat DoseTried((J+1),nDose);\n  arma::vec nTreated1(J+1);\n  nTreated1.zeros();\n  INVEC.zeros();\n\n  arma::vec INVECNEW=INVEC;\n  arma::vec Y2;\n  arma::vec I2;\n  arma::vec Groups2;\n  arma::vec Doses2;\n  arma::vec GetGroup=StoppedGroups;\n\n\n  //Wrap nreps around\n  for(rep=0;rep<nSims;rep++){\n\n\n\n\n    if(rep%100==0){\n\n      Rf_PrintValue(wrap(rep));\n\n      Rprintf(\"Simulations Finished\");\n\n    }\n\n    //Wrap i around\n\n    MeanVec.zeros();\n    //Reset all trial vectors\n    trialtime=0;\n    stopped=0;\n    OptDose.zeros();\n    StoppedGroups.zeros();\n    SuspendGroups.zeros();\n    TriedGroups.zeros();\n    Y.zeros();\n    I.zeros();\n    Times.zeros();\n    ACC.zeros();\n    Groups.zeros();\n    Doses.zeros();\n    GLast.zeros()+10000;\n    nTreated.zeros();\n    DoseTried.zeros();\n\n    NTox.zeros();\n\n\n\n\n    //Enroll the first patient\n\n    Group=Sample2(groupprob);\n\n    Groups[0]=Group;\n\n    Doses[0]=Dose[DoseStart[Group]];\n\n    nTreated[Group]=nTreated[Group]+1;\n\n    ACC[0]=0;\n\n    if(Family==0){\n      Times(0)=R::rexp(Param1(Group,DoseStart[Group]));\n    }\n\n\n\n    if(Family==1){\n      Times[0]=R::rgamma(Param1(Group,DoseStart[Group]),1/Param2(Group,DoseStart[Group]));\n    }\n\n    if(Family==2){\n      Times[0]=R::rlnorm(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n    }\n\n\n    if(Family==3){\n      if(as_scalar(arma::randu(1))<Param1(Group,DoseStart[Group])){\n        Times[0]=as_scalar(arma::randu(1))*T1;\n      }else{\n        Times[0]=T1+1;\n      }\n    }\n\n    if(Family==4){\n      Times[0]=R::rweibull(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n    }\n\n    DoseTried(Group,DoseStart(Group))=1;\n\n\n    if(DoseStart[Group]==0){\n      nTreated1[Group]=nTreated1[Group]+1;\n    }\n\n    for(i=1;i<Nmax;i++){\n      //Start the Trial, Let's do this\n\n      DEC=0;\n\n      trialtime=trialtime+R::rexp(1/Accrue);\n      Group=Sample2(groupprob);\n      //Now its not in a stopped group or a subgroup so let's do our MCMC\n\n\n\n\n\n      //Enrolling in a new subgroup\n      if(TriedGroups[Group]==0){\n\n        nTreated[Group]=nTreated[Group]+1;\n\n        if(DoseStart[Group]==0){\n          nTreated1[Group]=nTreated1[Group]+1;\n        }\n\n        Groups[i]=Group;\n\n        Doses[i]=Dose[DoseStart[Group]];\n\n        ACC[i]=trialtime;\n\n        if(Family==0){\n          Times(i)=R::rexp(Param1(Group,DoseStart[Group]));\n        }\n\n\n\n        if(Family==1){\n          Times[i]=R::rgamma(Param1(Group,DoseStart[Group]),1/Param2(Group,DoseStart[Group]));\n        }\n\n        if(Family==2){\n          Times[i]=R::rlnorm(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n        }\n\n\n        if(Family==3){\n          if(as_scalar(arma::randu(1))<Param1(Group,DoseStart[Group])){\n            Times[i]=as_scalar(arma::randu(1))*T1;\n          }else{\n            Times[i]=T1+1;\n          }\n        }\n\n        if(Family==4){\n          Times[i]=R::rweibull(Param1(Group,DoseStart[Group]),Param2(Group,DoseStart[Group]));\n        }\n\n\n        DoseTried(Group,DoseStart(Group))=1;\n        TriedGroups[Group]=1;\n\n      }else{\n        //Not in a new subgroup, let's do our MCMC\n\n        DEC=0;\n\n        while(DEC==0){\n          //If this patient group is\n\n          I.zeros();\n          Y.zeros();\n\n          //Setup Y\n          for(k=0;k<i;k++){\n            Y[k]=min1(min1(Times[k],trialtime-ACC[k]),T1);\n            if(Times[k]==Y[k]){\n              I[k]=1;\n            }\n          }\n\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=meanmu;\n          slope=meanslope;\n          INVEC.zeros();\n          INVECNEW.zeros();\n          INVEC = INVEC+1;\n          a=MeanInts;\n          b=MeanSlopes;\n\n\n          for(m=0;m<GroupMem.n_rows;m++){\n            GroupMem[m]=m+1;\n          }\n\n          GroupMemProp=GroupMem;\n\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n                for(k=0;k<(J+1);k++){\n                  if((IntA[k]/NumA[k])>.5){\n                    avar[k]=avar[k]*2;\n                  }\n\n                  if((IntA[k]/NumA[k])<.2){\n                    avar[k]=avar[k]/2;\n                  }\n\n\n\n\n\n\n\n\n                  if((IntB[k]/NumB[k])>.5){\n                    bvar[k]=bvar[k]*2;\n                  }\n\n                  if((IntB[k]/NumB[k])<.2){\n                    bvar[k]=bvar[k]/2;\n                  }\n\n\n\n                }\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n                NumA=NumA.zeros()+2;\n                NumB=NumB.zeros()+2;\n                IntA=IntA.zeros()+1;\n                IntB=IntB.zeros()+1;\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n            for(k=0;k<aprop.n_rows;k++){\n\n              if(INVEC[k]>0){\n\n                aprop=a;\n                aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n                alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n                if(U<alpha){\n                  a(k)=aprop(k);\n                  IntA[k]=IntA[k]+1;\n                }\n\n                NumA=NumA+1;\n\n\n              }\n            }\n            //Now do a MH step for the slope\n\n            for(k=0;k<aprop.size();k++){\n\n              if(INVEC[k]>0){\n                bprop=b;\n                bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n                alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n                z9[0]=alpha;\n\n                //  Rf_PrintValue(wrap(z9));\n\n                if(U<alpha){\n                  b[k]=bprop[k];\n                  IntB[k]=IntB[k]+1;\n                }\n\n              }\n\n            }\n\n\n            NumB=NumB+1;\n\n\n\n            //Spike And Slab\n\n\n            U=as_scalar(arma::randu(1));\n\n\n            if((3*U)<1){\n              //Add All or delete all\n\n              if(sum(INVEC)==(J)){\n                //Auto Delete Move\n\n\n\n\n                aprop.zeros();\n                bprop.zeros();\n\n                GroupMemProp=GroupMem;\n                //Now Randomly Draw Our New Group Assignment\n\n\n                INVECNEW.zeros();\n\n\n\n\n                GroupMemProp.zeros();\n\n\n\n\n                alpha=0;\n                for(k=0;k<bprop.n_rows;k++){\n                  alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                }\n\n\n\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                if(U<alpha){\n                  b.zeros();\n                  a.zeros();\n                  GroupMem.zeros();\n                  INVEC.zeros();\n\n                  //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n                }\n\n\n\n\n\n\n              }else{\n\n\n                if(sum(INVEC)==0){\n                  //Autho Add Move\n\n                  //ADD Move\n\n                  for(k=0;k<aprop.n_rows;k++){\n                    aprop[k]=as_scalar(arma::randn(1));\n                    bprop[k]=as_scalar(arma::randn(1))/10;\n                    GroupMemProp[k]=k+1;\n                  }\n\n\n\n                  //Density when 0 is automatically 1 so no proposal needed\n\n                  alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                  for(k=0;k<aprop.n_rows;k++){\n\n\n                    alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n                  }\n\n\n\n\n                  alpha=alpha + log(sum(INVEC)+1);\n\n                  U=log(as_scalar(arma::randu(1)));\n\n                  z9[0]=alpha;\n\n                  //  Rf_PrintValue(wrap(z9));\n\n                  if(U<alpha){\n\n                    for(k=0;k<aprop.n_rows;k++){\n                      b[k]=bprop[k];\n                      a[k]=aprop[k];\n                      INVEC[k]=1;\n                      GroupMem[k]=k+1;\n                    }\n\n\n                  }\n\n\n\n\n                }else{\n                  //Randomly Decide to add or Delete\n\n                  U=as_scalar(arma::randu(1));\n\n\n                  if(U<.5){\n                    //Add\n\n\n                    //ADD Move\n\n                    for(k=0;k<aprop.n_rows;k++){\n                      aprop[k]=as_scalar(arma::randn(1));\n                      bprop[k]=as_scalar(arma::randn(1))/10;\n                      GroupMemProp[k]=k+1;\n                    }\n\n\n\n                    //Density when 0 is automatically 1 so no proposal needed\n\n                    alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                    for(k=0;k<aprop.n_rows;k++){\n\n\n                      alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n                    }\n\n\n\n\n                    alpha=alpha + log(sum(INVEC)+1);\n\n                    U=log(as_scalar(arma::randu(1)));\n\n                    z9[0]=alpha;\n\n                    //  Rf_PrintValue(wrap(z9));\n\n                    if(U<alpha){\n\n                      for(k=0;k<aprop.n_rows;k++){\n                        b[k]=bprop[k];\n                        a[k]=aprop[k];\n                        INVEC[k]=1;\n                        GroupMem[k]=k+1;\n                      }\n\n\n                    }\n\n\n\n                  }else{\n                    //Delete All\n\n\n\n\n                    aprop.zeros();\n                    bprop.zeros();\n\n                    GroupMemProp=GroupMem;\n                    //Now Randomly Draw Our New Group Assignment\n\n\n                    INVECNEW.zeros();\n\n\n\n\n                    GroupMemProp.zeros();\n\n\n\n\n                    alpha=0;\n                    for(k=0;k<bprop.n_rows;k++){\n                      alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                    }\n\n\n\n\n\n                    //Density when 0 is automatically 1 so no proposal needed\n                    alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                    U=log(as_scalar(arma::randu(1)));\n\n\n\n                    if(U<alpha){\n                      b.zeros();\n                      a.zeros();\n                      GroupMem.zeros();\n                      INVEC.zeros();\n\n                      //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n                    }\n\n\n\n\n                  }\n\n\n\n\n\n                }\n\n\n\n\n              }\n\n\n\n\n\n\n\n\n\n            }else{\n\n\n\n              //Should we swap?\n              if((sum(INVEC)==J) || (sum(INVEC)==0)){\n                //Add/Delete\n\n\n\n                k=Sample1(J);\n\n                if(INVEC[k]==0){\n                  //ADD Move\n                  aprop=a;\n                  bprop=b;\n                  aprop[k]=as_scalar(arma::randn(1));\n                  bprop[k]=as_scalar(arma::randn(1))/10;\n\n                  GroupMemProp=GroupMem;\n                  GroupMemProp[k]=k+1;\n\n\n                  //Density when 0 is automatically 1 so no proposal needed\n                  alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                  alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n                  alpha=alpha + log(sum(INVEC)+1);\n\n                  U=log(as_scalar(arma::randu(1)));\n\n                  z9[0]=alpha;\n\n                  //  Rf_PrintValue(wrap(z9));\n\n                  if(U<alpha){\n                    b[k]=bprop[k];\n                    a[k]=aprop[k];\n                    INVEC[k]=1;\n                    GroupMem[k]=k+1;\n                  }\n\n\n                }else{\n                  //Delete Move\n                  aprop=a;\n                  bprop=b;\n                  //Delete Move\n                  aprop[k]=0;\n                  bprop[k]=0;\n\n                  GroupMemProp=GroupMem;\n                  //Now Randomly Draw Our New Group Assignment\n\n\n                  INVECNEW=INVEC;\n                  INVECNEW[k]=0;\n\n\n\n                  GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n                  //Density when 0 is automatically 1 so no proposal needed\n                  alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                  alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                  alpha=alpha-log(sum(INVEC)+1);\n\n                  U=log(as_scalar(arma::randu(1)));\n\n\n\n                  if(U<alpha){\n                    b[k]=0;\n                    a[k]=0;\n                    GroupMem=GroupMemProp;\n                    INVEC[k]=0;\n\n                    //If Any other GroupMEM are in this group, we need to delete them.\n\n                    for(j=0;j<GroupMem.n_rows;j++){\n                      if(GroupMem[j]==(k+1)){\n                        GroupMem[j]=GroupMem[k];\n                      }\n                    }\n\n\n\n                  }\n\n\n                }\n\n\n              }else{\n\n\n\n\n                if((3*U)>2){\n                  //Swap Move\n                  //Randomly Pick One In and One Out\n\n                  IntIN = GetIn(INVEC);\n                  IntOUT= GetOut(INVEC);\n\n                  //Now IntIN and IntOUT contain the entries that are currently in or out\n\n\n\n\n\n                }else{\n                  //Add/Delete\n\n\n\n                  k=Sample1(J);\n\n                  if(INVEC[k]==0){\n                    //ADD Move\n                    aprop=a;\n                    bprop=b;\n                    aprop[k]=as_scalar(arma::randn(1));\n                    bprop[k]=as_scalar(arma::randn(1))/10;\n\n                    GroupMemProp=GroupMem;\n                    GroupMemProp[k]=k+1;\n\n\n                    //Density when 0 is automatically 1 so no proposal needed\n                    alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                    alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n                    alpha=alpha + log(sum(INVEC)+1);\n\n                    U=log(as_scalar(arma::randu(1)));\n\n                    z9[0]=alpha;\n\n                    //  Rf_PrintValue(wrap(z9));\n\n                    if(U<alpha){\n                      b[k]=bprop[k];\n                      a[k]=aprop[k];\n                      INVEC[k]=1;\n                      GroupMem[k]=k+1;\n                    }\n\n\n                  }else{\n                    //Delete Move\n                    aprop=a;\n                    bprop=b;\n                    //Delete Move\n                    aprop[k]=0;\n                    bprop[k]=0;\n\n                    GroupMemProp=GroupMem;\n                    //Now Randomly Draw Our New Group Assignment\n\n\n                    INVECNEW=INVEC;\n                    INVECNEW[k]=0;\n\n\n\n                    GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n                    //Density when 0 is automatically 1 so no proposal needed\n                    alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                    alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                    alpha=alpha-log(sum(INVEC)+1);\n\n                    U=log(as_scalar(arma::randu(1)));\n\n\n\n                    if(U<alpha){\n                      b[k]=0;\n                      a[k]=0;\n                      GroupMem=GroupMemProp;\n                      INVEC[k]=0;\n\n                      //If Any other GroupMEM are in this group, we need to delete them.\n\n                      for(j=0;j<GroupMem.n_rows;j++){\n                        if(GroupMem[j]==(k+1)){\n                          GroupMem[j]=GroupMem[k];\n                        }\n                      }\n\n\n\n                    }\n\n\n                  }\n\n\n                }\n\n\n\n              }\n\n            }\n\n\n\n\n\n\n            //Swap Group\n\n            for(k=0;k<J;k++){\n              if(INVEC[k]==0){\n\n                GroupMemProp=GroupMem;\n                //Now Randomly Draw Our New Group Assignment\n\n\n                INVECNEW=INVEC;\n                INVECNEW[k]=0;\n\n\n\n                GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha = LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                if(U<alpha){\n                  GroupMem[k]=GroupMemProp[k];\n                }\n              }\n\n            }\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   LikeMULTI(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n            alpha =   alpha+  LikeMULTI(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n              for(j=0;j<J;j++){;\n                astore(StoreInx,j)=INVEC(j);\n                bstore(StoreInx,j)=GroupMem[j];\n              }\n\n              mustore[StoreInx]=mu;\n              slopestore[StoreInx]=slope;\n              sigstore[StoreInx]=sig;\n\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n              aprop.zeros();\n              bprop.zeros();\n              for(j=0;j<J;j++){\n                for(k=0;k<J;k++){\n                  if(GroupMem[j]==(k+1)){\n                    aprop[j]=a[k];\n                    bprop[j]=b[k];\n                  }\n                }\n              }\n\n\n              for(k=0;k<(J+1);k++){\n\n                for(j=0;j<nDose;j++){\n                  eta1=0;\n\n                  if(k>0){\n                    eta1 = aprop[k-1]+exp(bprop[k-1]+slope)*Dose[j]+mu;\n                  }\n\n                  if(k==0){\n                    eta1=mu+exp(slope)*Dose[j];\n\n                  }\n\n                  //For all groups add the intercept and slope*Groups\n\n                  eta1=exp(eta1);\n\n                  if(eta1>100000){\n                    DoseProb(StoreInx, k*nDose+j) = 1;\n\n                  }else{\n                    DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                  }\n\n\n\n                }\n\n\n              }\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n\n\n\n\n\n\n          }\n\n          ///STOPHERE\n\n\n          StoppedGroups.zeros();\n\n          //Do we have a stopped group?\n          for(k=0;k<(J+1);k++){\n            eta2=0;\n\n            for(j=0;j<DoseProb.n_rows;j++){\n              //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n              if(DoseProb(j,k*nDose)>Target[k]){\n                eta2++;\n              }\n\n\n            }\n\n\n\n            if(eta2>(Upper[k]*DoseProb.n_rows)){\n              StoppedGroups[k]=1;\n            }\n\n          }\n\n\n\n\n          //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n          for(k=0;k<(J+1);k++){\n            if(nTreated1[k]<3){\n              StoppedGroups[k]=0;\n            }\n\n            if(nTreated1[k]>2){\n              GetGroup.zeros();\n              GetGroup[k]=1;\n\n              Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n              I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n              if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n                StoppedGroups[k]=0;\n              }\n\n            }\n\n\n          }\n\n\n\n\n\n\n          //    Rf_PrintValue(wrap(StoppedGroups));\n          if(sum(StoppedGroups)==(J+1)){\n            //Let's try the groups separately to make sure we aren't stopping unneccessarily\n            StoppedGroups.zeros();\n\n            for(g=0;g<(J+1);g++){\n              GetGroup.zeros();\n              GetGroup[g]=1;\n\n              Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n              I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n              Which1 = g;\n\n\n              if(Which1==0){\n                NewMean = meanmu;\n                NewSlope=meanslope;\n              }else{\n                NewMean = meanmu+MeanInts[Which1-1];\n                NewSlope=meanslope+MeanSlopes[Which1-1];\n              }\n\n\n\n\n\n              //Inner MCMC loop, only compute neccessary quantities. Reset counters\n              NumA=NumA.zeros()+2;\n              NumB=NumB.zeros()+2;\n              IntA=IntA.zeros()+1;\n              IntB = IntB.zeros()+1;\n              NumMu = 2;\n              NumSlope=2;\n              IntMu=1;\n              IntSlope=1;\n              avar=avar.zeros()+1;\n              bvar=bvar.zeros()+1;\n              muvar=1;\n              slopevar=1;\n              NumSig=2;\n              IntSig=1;\n              sigvar=1;\n              a.zeros();\n              b.zeros();\n              MeanVec.zeros();\n              GroupVec.zeros();\n              mu=NewMean;\n              slope=NewSlope;\n\n\n              for(m=0;m<B;m++){\n\n                if(m<(B/2 + 2)){\n                  if(m%100==0){\n\n\n\n\n                    if((IntMu/NumMu)>.5){\n                      muvar=muvar*2;\n                    }\n\n                    if((IntMu/NumMu)<.2){\n                      muvar=muvar/2;\n                    }\n\n\n                    if((IntSlope/NumSlope)>.5){\n                      slopevar=slopevar*2;\n                    }\n\n                    if((IntSlope/NumSlope)<.2){\n                      slopevar=slopevar/2;\n                    }\n\n\n\n\n\n\n\n                    NumMu = 2;\n                    NumSlope=2;\n                    IntMu=1;\n                    IntSlope=1;\n                    IntSig=1;\n                    NumSig=2;\n\n\n\n\n                  }\n                }\n\n\n\n\n\n\n\n\n\n                Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n                alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n                if(U<alpha){\n                  mu=Munew;\n                  IntMu=IntMu+1;\n                }\n\n                NumMu=NumMu+1;\n\n\n\n\n                //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n                slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n                //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n                //Proposal ratio for beta\n\n                alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n                alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n                if(U<alpha){\n                  slope=slopenew;\n                  IntSlope=IntSlope+1;\n                }\n                NumSlope=NumSlope+1;\n\n\n\n\n\n                if(m>(B-B1-1)){\n                  //Make OptDose and StoppedGroups\n                  StoreInx=m-B1;\n\n\n\n                  //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n                  //First nDose\n\n\n                  k=Which1;\n\n                  for(j=0;j<nDose;j++){\n                    eta1=0;\n\n\n\n\n                    eta1=mu+exp(slope)*Dose[j];\n\n\n\n                    //For all groups add the intercept and slope*Groups\n\n                    eta1=exp(eta1);\n\n                    if(eta1>100000){\n                      DoseProb(StoreInx, k*nDose+j) = 1;\n\n                    }else{\n                      DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                    }\n\n\n\n                  }\n\n\n\n                  //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n                }\n\n                //End MCMC\n              }\n              //Is our very last group stopped?\n\n              k=Which1;\n              eta2=0;\n\n              for(j=0;j<DoseProb.n_rows;j++){\n                //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n                if(DoseProb(j,k*nDose)>Target[k]){\n                  eta2++;\n                }\n\n\n              }\n\n\n              if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n                StoppedGroups[Which1]=1;\n              }\n\n\n\n\n\n\n            }\n\n\n\n\n\n          }\n\n\n\n\n          //Should we stop the trial?\n          if(sum(StoppedGroups)==(J+1)){\n            stopped=1;\n            break;\n          }\n\n\n\n\n\n\n\n\n\n          if(StoppedGroups[Group]==0){\n            //Enroll this patient\n            DEC=1;\n\n\n            if(sum(StoppedGroups)>0){\n              //If we have a stopped group, REMOVE IT\n\n              Y2=ReturnStoppedY(Y,I,Groups,StoppedGroups,i);\n              I2=ReturnStoppedI(Y,I,Groups,StoppedGroups,i);\n              Groups2=ReturnStoppedGroups(Y,I,Groups,StoppedGroups,i);\n              Doses2=ReturnStoppedY(Doses,I,Groups,StoppedGroups,i);\n\n\n\n\n              if(sum(StoppedGroups)==J){\n                //We just have one group left\n\n                for(k=0;k<StoppedGroups.n_rows;k++){\n                  if(StoppedGroups[k]==0){\n                    Which1=k;\n                  }\n                }\n\n\n                if(Which1==0){\n                  NewMean = meanmu;\n                  NewSlope=meanslope;\n                }else{\n                  NewMean = meanmu+MeanInts[Which1-1];\n                  NewSlope=meanslope+MeanSlopes[Which1-1];\n                }\n\n\n                //Inner MCMC loop, only compute neccessary quantities. Reset counters\n                NumA=NumA.zeros()+2;\n                NumB=NumB.zeros()+2;\n                IntA=IntA.zeros()+1;\n                IntB = IntB.zeros()+1;\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                avar=avar.zeros()+1;\n                bvar=bvar.zeros()+1;\n                muvar=1;\n                slopevar=1;\n                NumSig=2;\n                IntSig=1;\n                sigvar=1;\n                a.zeros();\n                b.zeros();\n                MeanVec.zeros();\n                GroupVec.zeros();\n                mu=NewMean;\n                slope=NewSlope;\n\n\n                for(m=0;m<B;m++){\n\n                  if(m<(B/2 + 2)){\n                    if(m%100==0){\n\n\n\n\n                      if((IntMu/NumMu)>.5){\n                        muvar=muvar*2;\n                      }\n\n                      if((IntMu/NumMu)<.2){\n                        muvar=muvar/2;\n                      }\n\n\n                      if((IntSlope/NumSlope)>.5){\n                        slopevar=slopevar*2;\n                      }\n\n                      if((IntSlope/NumSlope)<.2){\n                        slopevar=slopevar/2;\n                      }\n\n\n\n\n\n\n\n                      NumMu = 2;\n                      NumSlope=2;\n                      IntMu=1;\n                      IntSlope=1;\n                      IntSig=1;\n                      NumSig=2;\n\n\n\n\n                    }\n                  }\n\n\n\n\n\n\n\n\n\n                  Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n                  alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n                  U=log(as_scalar(arma::randu(1)));\n\n                  if(U<alpha){\n                    mu=Munew;\n                    IntMu=IntMu+1;\n                  }\n\n                  NumMu=NumMu+1;\n\n\n\n\n                  //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n                  slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n                  //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n                  //Proposal ratio for beta\n\n                  alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n                  alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n                  U=log(as_scalar(arma::randu(1)));\n\n\n\n                  U=log(as_scalar(arma::randu(1)));\n\n                  if(U<alpha){\n                    slope=slopenew;\n                    IntSlope=IntSlope+1;\n                  }\n                  NumSlope=NumSlope+1;\n\n\n\n\n\n                  if(m>(B-B1-1)){\n                    //Make OptDose and StoppedGroups\n                    StoreInx=m-B1;\n\n\n\n                    //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n                    //First nDose\n\n\n                    k=Which1;\n\n                    for(j=0;j<nDose;j++){\n                      eta1=0;\n\n\n\n\n                      eta1=mu+exp(slope)*Dose[j];\n\n\n\n                      //For all groups add the intercept and slope*Groups\n\n                      eta1=exp(eta1);\n\n                      if(eta1>100000){\n                        DoseProb(StoreInx, k*nDose+j) = 1;\n\n                      }else{\n                        DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                      }\n\n\n\n                    }\n\n\n\n                    //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n                  }\n\n                  //End MCMC\n                }\n                //Is our very last group stopped?\n\n                k=Which1;\n                eta2=0;\n\n                for(j=0;j<DoseProb.n_rows;j++){\n                  //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n                  if(DoseProb(j,k*nDose)>Target[k]){\n                    eta2++;\n                  }\n\n\n                }\n\n\n                if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n                  StoppedGroups[Which1]=1;\n                }\n\n\n\n\n\n\n              }\n\n\n\n\n              //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n              for(k=0;k<(J+1);k++){\n                if(nTreated1[k]<3){\n                  StoppedGroups[k]=0;\n                }\n\n                if(nTreated1[k]>2){\n                  GetGroup.zeros();\n                  GetGroup[k]=1;\n\n                  Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n                  I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n                  Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n                  if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n                    StoppedGroups[k]=0;\n                  }\n\n                }\n\n\n              }\n\n\n\n\n\n              if(sum(StoppedGroups)==(J+1)){\n                stopped=1;\n\n                Rf_PrintValue(wrap(StoppedGroups));\n                Rprintf(\"It Stopped\");\n\n                Rf_PrintValue(wrap(Y2));\n                Rf_PrintValue(wrap(I2));\n                Rf_PrintValue(wrap(Doses2));\n\n\n                break;\n              }\n\n\n\n\n            }\n\n\n\n\n\n          }else{\n\n            trialtime=trialtime+R::rexp(1/Accrue);\n            Group=Sample2(groupprob);\n\n          }\n\n          //Do We have ANOTHER STOPPED GROUP?\n          //Should we stop the trial?\n\n\n\n\n\n\n\n          if(sum(StoppedGroups)==(J+1)){\n            stopped=1;\n\n            Rf_PrintValue(wrap(StoppedGroups));\n            Rprintf(\"It Stopped\");\n\n            Rf_PrintValue(wrap(Y2));\n            Rf_PrintValue(wrap(I2));\n            Rf_PrintValue(wrap(Doses2));\n\n\n            break;\n          }\n\n\n        }\n\n        //Ok now let's enroll this patient, Whats the Optimal Dose\n\n        //If Stopped==1, Get out of the trial\n        if(stopped==1){\n          break;\n        }\n\n\n\n        if(MEANS==0){\n          for(k=0;k<(J+1);k++){\n            for(j=0;j<nDose;j++){\n              MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n            }\n\n          }\n\n\n\n        }\n\n\n        //Determine Optimal Dose\n        k=Group;\n        eta1=MinVec(abs(MeanVec.row(k).t()-Target(k)));\n        j=0;\n\n\n\n\n        GroupVec = abs(MeanVec.row(k).t()-Target(k));\n\n        while(GroupVec[j]!=eta1 ){\n          j++;\n          //Loop Proceeds until the minimum difference is reached\n        }\n\n        OptDose[k]=j;\n\n\n\n\n        //Now we have the subgroup specific optimal doses in the vector OptDose\n\n\n\n        //Now let's see if the dose is bigger than the largest dose.\n        if(OptDose[Group]>=nDose){\n          OptDose[Group]=nDose-1;\n        }\n\n\n\n        //Is this dose bigger than the dose higher than what's been tried?\n        if(DoseTried(Group,OptDose[Group])==0){\n          j=0;\n\n          while(DoseTried(Group,j)==1){\n            j++;\n          }\n\n          OptDose[Group]=j;\n\n        }\n\n\n\n\n\n\n        //Assign Patient to subgroup, optdose, add accrual time.\n\n        Groups[i]=Group;\n        if(OptDose[Group]==0){\n          //If we assign one at the lowest dose add this\n          nTreated1[Group]=nTreated1[Group]+1;\n        }\n        nTreated[Group]=nTreated[Group]+1;\n\n        //If this is the 3rd patient treated in this subgroup with the lowest dose, suspend accrual for TGroup\n        if(nTreated[Group]==3){\n          SuspendGroups[Group]=1;\n          GLast[Group]=trialtime;\n        }\n\n\n\n        Doses[i]=Dose[OptDose[Group]];\n\n\n        ACC[i]=trialtime;\n        //Based on the Group and Optimal dose, randomly generate the next patient Data\n\n\n        if(Family==0){\n          Times(i)=R::rexp(Param1(Group,OptDose[Group]));\n        }\n\n\n\n        if(Family==1){\n          Times[i]=R::rgamma(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n        if(Family==2){\n          Times[i]=R::rlnorm(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n\n        if(Family==3){\n          if(as_scalar(arma::randu(1))<Param1(Group,OptDose[Group])){\n            Times[i]=as_scalar(arma::randu(1))*T1;\n          }else{\n            Times[i]=T1+1;\n          }\n        }\n\n        if(Family==4){\n          Times[i]=R::rweibull(Param1(Group,OptDose[Group]),Param2(Group,OptDose[Group]));\n        }\n\n\n        DoseTried(Group,OptDose(Group))=1;\n\n\n\n\n\n\n\n\n\n\n\n\n      }\n\n\n\n\n      //End of the i loop, now we have ALL the patients\n    }\n\n\n\n    //Now let's make the final decision.\n    if(stopped==1){\n      //The trial Ended Early, i-1 is the index of the last patient enrolled.\n\n\n      for(k=0;k<i;k++){\n        for(j=0;j<(J+1);j++){\n          if(Groups[k]==j){\n            NTox[j]=NTox[j]+I[k];\n          }\n        }\n      }\n\n\n      //All Optimal Doses are -1\n      for(k=0;k<(J+1);k++){\n        OptDose[k]=-1;\n      }\n\n\n    }else{\n      //The trial did NOT end early. Follow patients out until end of trial and get the optimal doses\n      trialtime=trialtime+T1;\n\n\n\n      Y.zeros();\n      I.zeros();\n\n      //Setup Y\n      for(k=0;k<Nmax;k++){\n\n        Y[k]=min1(Times[k],T1);\n\n\n        if(Times[k]<T1){\n          I[k]=1;\n        }\n      }\n\n\n\n\n\n      //Inner MCMC loop, only compute neccessary quantities. Reset counters\n      NumA=NumA.zeros()+2;\n      NumB=NumB.zeros()+2;\n      IntA=IntA.zeros()+1;\n      IntB = IntB.zeros()+1;\n      NumMu = 2;\n      NumSlope=2;\n      IntMu=1;\n      IntSlope=1;\n      avar=avar.zeros()+1;\n      bvar=bvar.zeros()+1;\n      muvar=1;\n      slopevar=1;\n      NumSig=2;\n      IntSig=1;\n      sigvar=1;\n      a.zeros();\n      b.zeros();\n      MeanVec.zeros();\n      GroupVec.zeros();\n      mu=meanmu;\n      slope=meanslope;\n      INVEC.zeros();\n      INVECNEW.zeros();\n      INVEC = INVEC+1;\n      a=MeanInts;\n      b=MeanSlopes;\n\n\n      for(m=0;m<GroupMem.n_rows;m++){\n        GroupMem[m]=m+1;\n      }\n\n      GroupMemProp=GroupMem;\n\n      Rf_PrintValue(wrap(INVEC));\n      Rf_PrintValue(wrap(GroupMem));\n\n      for(m=0;m<B;m++){\n\n        if(m<(B/2 + 2)){\n          if(m%100==0){\n\n\n            for(k=0;k<(J+1);k++){\n              if((IntA[k]/NumA[k])>.5){\n                avar[k]=avar[k]*2;\n              }\n\n              if((IntA[k]/NumA[k])<.2){\n                avar[k]=avar[k]/2;\n              }\n\n\n\n\n\n\n\n\n              if((IntB[k]/NumB[k])>.5){\n                bvar[k]=bvar[k]*2;\n              }\n\n              if((IntB[k]/NumB[k])<.2){\n                bvar[k]=bvar[k]/2;\n              }\n\n\n\n            }\n\n\n            if((IntMu/NumMu)>.5){\n              muvar=muvar*2;\n            }\n\n            if((IntMu/NumMu)<.2){\n              muvar=muvar/2;\n            }\n\n\n            if((IntSlope/NumSlope)>.5){\n              slopevar=slopevar*2;\n            }\n\n            if((IntSlope/NumSlope)<.2){\n              slopevar=slopevar/2;\n            }\n\n\n\n\n\n            NumA=NumA.zeros()+2;\n            NumB=NumB.zeros()+2;\n            IntA=IntA.zeros()+1;\n            IntB=IntB.zeros()+1;\n\n            NumMu = 2;\n            NumSlope=2;\n            IntMu=1;\n            IntSlope=1;\n            IntSig=1;\n            NumSig=2;\n\n\n\n\n          }\n        }\n\n\n\n        for(k=0;k<aprop.n_rows;k++){\n\n          if(INVEC[k]>0){\n\n            aprop=a;\n            aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n            alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n            if(U<alpha){\n              a(k)=aprop(k);\n              IntA[k]=IntA[k]+1;\n            }\n\n            NumA=NumA+1;\n\n\n          }\n        }\n        //Now do a MH step for the slope\n\n        for(k=0;k<aprop.size();k++){\n\n          if(INVEC[k]>0){\n            bprop=b;\n            bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n            alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            z9[0]=alpha;\n\n            //  Rf_PrintValue(wrap(z9));\n\n            if(U<alpha){\n              b[k]=bprop[k];\n              IntB[k]=IntB[k]+1;\n            }\n\n          }\n\n        }\n\n\n        NumB=NumB+1;\n\n\n\n        //Spike And Slab\n\n\n        U=as_scalar(arma::randu(1));\n\n\n        if((3*U)<1){\n          //Add All or delete all\n\n          if(sum(INVEC)==(J)){\n            //Auto Delete Move\n\n\n\n\n            aprop.zeros();\n            bprop.zeros();\n\n            GroupMemProp=GroupMem;\n            //Now Randomly Draw Our New Group Assignment\n\n\n            INVECNEW.zeros();\n\n\n\n\n            GroupMemProp.zeros();\n\n\n\n\n            alpha=0;\n            for(k=0;k<bprop.n_rows;k++){\n              alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n            }\n\n\n\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            if(U<alpha){\n              b.zeros();\n              a.zeros();\n              GroupMem.zeros();\n              INVEC.zeros();\n\n              //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n            }\n\n\n\n\n\n\n          }else{\n\n\n            if(sum(INVEC)==0){\n              //Autho Add Move\n\n              //ADD Move\n\n              for(k=0;k<aprop.n_rows;k++){\n                aprop[k]=as_scalar(arma::randn(1));\n                bprop[k]=as_scalar(arma::randn(1))/10;\n                GroupMemProp[k]=k+1;\n              }\n\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n\n              alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n              for(k=0;k<aprop.n_rows;k++){\n\n\n                alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n              }\n\n\n\n\n              alpha=alpha + log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n              z9[0]=alpha;\n\n              //  Rf_PrintValue(wrap(z9));\n\n              if(U<alpha){\n\n                for(k=0;k<aprop.n_rows;k++){\n                  b[k]=bprop[k];\n                  a[k]=aprop[k];\n                  INVEC[k]=1;\n                  GroupMem[k]=k+1;\n                }\n\n\n              }\n\n\n\n\n            }else{\n              //Randomly Decide to add or Delete\n\n              U=as_scalar(arma::randu(1));\n\n\n              if(U<.5){\n                //Add\n\n\n                //ADD Move\n\n                for(k=0;k<aprop.n_rows;k++){\n                  aprop[k]=as_scalar(arma::randn(1));\n                  bprop[k]=as_scalar(arma::randn(1))/10;\n                  GroupMemProp[k]=k+1;\n                }\n\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n\n                alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                for(k=0;k<aprop.n_rows;k++){\n\n\n                  alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n                }\n\n\n\n\n                alpha=alpha + log(sum(INVEC)+1);\n\n                U=log(as_scalar(arma::randu(1)));\n\n                z9[0]=alpha;\n\n                //  Rf_PrintValue(wrap(z9));\n\n                if(U<alpha){\n\n                  for(k=0;k<aprop.n_rows;k++){\n                    b[k]=bprop[k];\n                    a[k]=aprop[k];\n                    INVEC[k]=1;\n                    GroupMem[k]=k+1;\n                  }\n\n\n                }\n\n\n\n              }else{\n                //Delete All\n\n\n\n\n                aprop.zeros();\n                bprop.zeros();\n\n                GroupMemProp=GroupMem;\n                //Now Randomly Draw Our New Group Assignment\n\n\n                INVECNEW.zeros();\n\n\n\n\n                GroupMemProp.zeros();\n\n\n\n\n                alpha=0;\n                for(k=0;k<bprop.n_rows;k++){\n                  alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                }\n\n\n\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                if(U<alpha){\n                  b.zeros();\n                  a.zeros();\n                  GroupMem.zeros();\n                  INVEC.zeros();\n\n                  //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n                }\n\n\n\n\n              }\n\n\n\n\n\n            }\n\n\n\n\n          }\n\n\n\n\n\n\n\n\n\n        }else{\n\n\n\n          //Should we swap?\n          if((sum(INVEC)==J) || (sum(INVEC)==0)){\n            //Add/Delete\n\n\n\n            k=Sample1(J);\n\n            if(INVEC[k]==0){\n              //ADD Move\n              aprop=a;\n              bprop=b;\n              aprop[k]=as_scalar(arma::randn(1));\n              bprop[k]=as_scalar(arma::randn(1))/10;\n\n              GroupMemProp=GroupMem;\n              GroupMemProp[k]=k+1;\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n              alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n              alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n              alpha=alpha + log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n              z9[0]=alpha;\n\n              //  Rf_PrintValue(wrap(z9));\n\n              if(U<alpha){\n                b[k]=bprop[k];\n                a[k]=aprop[k];\n                INVEC[k]=1;\n                GroupMem[k]=k+1;\n              }\n\n\n            }else{\n              //Delete Move\n              aprop=a;\n              bprop=b;\n              //Delete Move\n              aprop[k]=0;\n              bprop[k]=0;\n\n              GroupMemProp=GroupMem;\n              //Now Randomly Draw Our New Group Assignment\n\n\n              INVECNEW=INVEC;\n              INVECNEW[k]=0;\n\n\n\n              GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n              alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n              alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n              alpha=alpha-log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n\n\n              if(U<alpha){\n                b[k]=0;\n                a[k]=0;\n                GroupMem=GroupMemProp;\n                INVEC[k]=0;\n\n                //If Any other GroupMEM are in this group, we need to delete them.\n\n                for(j=0;j<GroupMem.n_rows;j++){\n                  if(GroupMem[j]==(k+1)){\n                    GroupMem[j]=GroupMem[k];\n                  }\n                }\n\n\n\n              }\n\n\n            }\n\n\n          }else{\n\n\n\n\n            if((3*U)>2){\n              //Swap Move\n              //Randomly Pick One In and One Out\n\n              IntIN = GetIn(INVEC);\n              IntOUT= GetOut(INVEC);\n\n              //Now IntIN and IntOUT contain the entries that are currently in or out\n\n\n\n\n\n            }else{\n              //Add/Delete\n\n\n\n              k=Sample1(J);\n\n              if(INVEC[k]==0){\n                //ADD Move\n                aprop=a;\n                bprop=b;\n                aprop[k]=as_scalar(arma::randn(1));\n                bprop[k]=as_scalar(arma::randn(1))/10;\n\n                GroupMemProp=GroupMem;\n                GroupMemProp[k]=k+1;\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n                alpha=alpha + log(sum(INVEC)+1);\n\n                U=log(as_scalar(arma::randu(1)));\n\n                z9[0]=alpha;\n\n                //  Rf_PrintValue(wrap(z9));\n\n                if(U<alpha){\n                  b[k]=bprop[k];\n                  a[k]=aprop[k];\n                  INVEC[k]=1;\n                  GroupMem[k]=k+1;\n                }\n\n\n              }else{\n                //Delete Move\n                aprop=a;\n                bprop=b;\n                //Delete Move\n                aprop[k]=0;\n                bprop[k]=0;\n\n                GroupMemProp=GroupMem;\n                //Now Randomly Draw Our New Group Assignment\n\n\n                INVECNEW=INVEC;\n                INVECNEW[k]=0;\n\n\n\n                GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n                //Density when 0 is automatically 1 so no proposal needed\n                alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n                alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n                alpha=alpha-log(sum(INVEC)+1);\n\n                U=log(as_scalar(arma::randu(1)));\n\n\n\n                if(U<alpha){\n                  b[k]=0;\n                  a[k]=0;\n                  GroupMem=GroupMemProp;\n                  INVEC[k]=0;\n\n                  //If Any other GroupMEM are in this group, we need to delete them.\n\n                  for(j=0;j<GroupMem.n_rows;j++){\n                    if(GroupMem[j]==(k+1)){\n                      GroupMem[j]=GroupMem[k];\n                    }\n                  }\n\n\n\n                }\n\n\n              }\n\n\n            }\n\n\n\n          }\n\n        }\n\n\n\n\n\n\n        //Swap Group\n\n        for(k=0;k<J;k++){\n          if(INVEC[k]==0){\n\n            GroupMemProp=GroupMem;\n            //Now Randomly Draw Our New Group Assignment\n\n\n            INVECNEW=INVEC;\n            INVECNEW[k]=0;\n\n\n\n            GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha = LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            if(U<alpha){\n              GroupMem[k]=GroupMemProp[k];\n            }\n          }\n\n        }\n\n\n\n\n\n\n        Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n        alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   LikeMULTI(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n        if(U<alpha){\n          mu=Munew;\n          IntMu=IntMu+1;\n        }\n\n        NumMu=NumMu+1;\n\n\n\n\n        //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n        slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n        //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n        //Proposal ratio for beta\n\n        alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n        alpha =   alpha+  LikeMULTI(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n\n\n        U=log(as_scalar(arma::randu(1)));\n\n        if(U<alpha){\n          slope=slopenew;\n          IntSlope=IntSlope+1;\n        }\n        NumSlope=NumSlope+1;\n\n\n        if(m>(B-B1-1)){\n          //Make OptDose and StoppedGroups\n          StoreInx=m-B1;\n\n          for(j=0;j<J;j++){;\n            astore(StoreInx,j)=INVEC(j);\n            bstore(StoreInx,j)=GroupMem[j];\n          }\n\n          mustore[StoreInx]=mu;\n          slopestore[StoreInx]=slope;\n          sigstore[StoreInx]=sig;\n\n\n          //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n          //First nDose\n\n          aprop.zeros();\n          bprop.zeros();\n          for(j=0;j<J;j++){\n            for(k=0;k<J;k++){\n              if(GroupMem[j]==(k+1)){\n                aprop[j]=a[k];\n                bprop[j]=b[k];\n              }\n            }\n          }\n\n\n          for(k=0;k<(J+1);k++){\n\n            for(j=0;j<nDose;j++){\n              eta1=0;\n\n              if(k>0){\n                eta1 = aprop[k-1]+exp(bprop[k-1]+slope)*Dose[j]+mu;\n              }\n\n              if(k==0){\n                eta1=mu+exp(slope)*Dose[j];\n\n              }\n\n              //For all groups add the intercept and slope*Groups\n\n              eta1=exp(eta1);\n\n              if(eta1>100000){\n                DoseProb(StoreInx, k*nDose+j) = 1;\n\n              }else{\n                DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n              }\n\n\n\n            }\n\n\n          }\n          //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n        }\n\n        //End MCMC\n\n\n\n\n\n\n      }\n\n      Rf_PrintValue(wrap(INVEC));\n      Rf_PrintValue(wrap(GroupMem));\n      //Get Optimal Dose\n\n\n      StoppedGroups.zeros();\n      //Get MeanVec\n      //reset to means\n\n\n\n\n      //Now we have the mean vector\n\n\n\n      //Do we have a stopped group?\n      for(k=0;k<(J+1);k++){\n        eta2=0;\n\n        for(j=0;j<DoseProb.n_rows;j++){\n          //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n          if(DoseProb(j,k*nDose)>Target[k]){\n            eta2++;\n          }\n\n\n        }\n\n\n\n\n\n\n\n        if(eta2>(Upper[k]*DoseProb.n_rows)){\n          StoppedGroups[k]=1;\n        }\n\n      }\n\n\n\n\n\n\n      if(sum(StoppedGroups)>0){\n        //If we have a stopped group, REMOVE IT\n\n        Y2=ReturnStoppedY(Y,I,Groups,StoppedGroups,i);\n        I2=ReturnStoppedI(Y,I,Groups,StoppedGroups,i);\n        Groups2=ReturnStoppedGroups(Y,I,Groups,StoppedGroups,i);\n        Doses2=ReturnStoppedY(Doses,I,Groups,StoppedGroups,i);\n\n\n\n\n        if(sum(StoppedGroups)==J){\n          //We just have one group left\n\n          for(k=0;k<StoppedGroups.n_rows;k++){\n            if(StoppedGroups[k]==0){\n              Which1=k;\n            }\n          }\n\n\n          if(Which1==0){\n            NewMean = meanmu;\n            NewSlope=meanslope;\n          }else{\n            NewMean = meanmu+MeanInts[Which1-1];\n            NewSlope=meanslope+MeanSlopes[Which1-1];\n          }\n\n          z9[0]=NewMean;\n          z9[1]=NewSlope;\n          Rf_PrintValue(z9);\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=NewMean;\n          slope=NewSlope;\n\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n            alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n              for(j=0;j<J;j++){;\n                astore(StoreInx,j)=INVEC(j);\n                bstore(StoreInx,j)=GroupMem[j];\n              }\n\n              mustore(StoreInx)=mu;\n              slopestore(StoreInx)=slope;\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n\n              k=Which1;\n\n              for(j=0;j<nDose;j++){\n                eta1=0;\n\n\n\n\n                eta1=mu+exp(slope)*Dose[j];\n\n\n\n                //For all groups add the intercept and slope*Groups\n\n                eta1=exp(eta1);\n\n                if(eta1>100000){\n                  DoseProb(StoreInx, k*nDose+j) = 1;\n\n                }else{\n                  DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                }\n\n\n\n              }\n\n\n\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n          }\n          //Is our very last group stopped?\n\n          k=Which1;\n          eta2=0;\n\n          for(j=0;j<DoseProb.n_rows;j++){\n            //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n            if(DoseProb(j,k*nDose)>Target[k]){\n              eta2++;\n            }\n\n\n          }\n\n\n          if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n            StoppedGroups[Which1]=1;\n          }\n\n\n\n\n\n        }\n\n      }\n\n\n\n\n      //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n\n      //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n      for(k=0;k<(J+1);k++){\n        if(nTreated1[k]<3){\n          StoppedGroups[k]=0;\n        }\n\n        if(nTreated1[k]>2){\n          GetGroup.zeros();\n          GetGroup[k]=1;\n\n          Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n          I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n          Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n          if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n            StoppedGroups[k]=0;\n          }\n\n        }\n\n\n      }\n\n\n\n\n      //If all groups are stopped, let's do separate trials JUST TO MAKE SURE ONE GROUP IS NOT DOMINATING THE DECISION TO STOP!!\n\n\n      //    Rf_PrintValue(wrap(StoppedGroups));\n      if(sum(StoppedGroups)==(J+1)){\n        //Let's try the groups separately to make sure we aren't stopping unneccessarily\n        StoppedGroups.zeros();\n\n        for(g=0;g<(J+1);g++){\n          GetGroup.zeros();\n          GetGroup[g]=1;\n\n          Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n          I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n          Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n          Which1 = g;\n\n\n          if(Which1==0){\n            NewMean = meanmu;\n            NewSlope=meanslope;\n          }else{\n            NewMean = meanmu+MeanInts[Which1-1];\n            NewSlope=meanslope+MeanSlopes[Which1-1];\n          }\n\n\n\n\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=NewMean;\n          slope=NewSlope;\n\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n            alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n\n              k=Which1;\n\n              for(j=0;j<nDose;j++){\n                eta1=0;\n\n\n\n\n                eta1=mu+exp(slope)*Dose[j];\n\n\n\n                //For all groups add the intercept and slope*Groups\n\n                eta1=exp(eta1);\n\n                if(eta1>100000){\n                  DoseProb(StoreInx, k*nDose+j) = 1;\n\n                }else{\n                  DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                }\n\n\n\n              }\n\n\n\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n          }\n          //Is our very last group stopped?\n\n          k=Which1;\n          eta2=0;\n\n          for(j=0;j<DoseProb.n_rows;j++){\n            //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n            if(DoseProb(j,k*nDose)>Target[k]){\n              eta2++;\n            }\n\n\n          }\n\n\n          if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n            StoppedGroups[Which1]=1;\n          }\n\n\n\n\n\n\n        }\n\n\n\n\n\n      }\n\n\n\n\n      if(MEANS==0){\n        for(k=0;k<(J+1);k++){\n          for(j=0;j<nDose;j++){\n            MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n          }\n\n        }\n\n\n      }\n\n\n\n\n\n      //Determine Optimal Doses\n      for(k=0;k<(J+1);k++){\n\n        if(StoppedGroups(k)==1){\n          OptDose(k)=-1;\n        }else{\n          eta1=MinVec(abs(MeanVec.row(k).t()-Target[k]));\n          j=0;\n\n          GroupVec = abs(MeanVec.row(k).t()-Target[k]);\n\n          //  Rf_PrintValue(wrap(MeanVec));\n\n\n          while(GroupVec[j]!=eta1 ){\n            j++;\n            //Loop Proceeds until the minimum difference is reached\n          }\n\n          OptDose[k]=j;\n        }\n\n\n      }\n\n\n\n\n      //Is this dose bigger than the dose higher than what's been tried?\n      for(k=0;k<(J+1);k++){\n        if(StoppedGroups[k]==0){\n          for(j=0;j<(J+1);j++){\n            if(OptDose[j]>=nDose){\n              OptDose[j]=nDose-1;\n            }\n          }\n\n\n\n\n        }\n\n\n\n      }\n\n      //Is this dose bigger than the dose higher than what's been tried?\n      for(k=0;k<(J+1);k++){\n        if(StoppedGroups(k)==0){\n          if(DoseTried(k,OptDose[k])==0){\n            j=0;\n\n            while(DoseTried(k,j)==1){\n              j++;\n            }\n\n            OptDose[k]=j;\n\n          }\n        }\n      }\n\n\n    }\n\n\n\n\n    //Num Toxicities\n    for(k=0;k<Nmax;k++){\n      for(j=0;j<(J+1);j++){\n        if(Groups[k]==j){\n          NTox[j]=NTox[j]+I[k];\n        }\n      }\n    }\n\n\n\n    OptDose=OptDose+1;\n\n\n    TrialTimes(rep)=trialtime;\n    for(j=0;j<(J+1);j++){\n      OptimalDoses(rep,j)=OptDose(j);\n      NTOX(rep,j)=NTox(j);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    //Fill in Doses and Groups Treated\n    for(j=0;j<Nmax;j++){\n      DoseStore(rep,j)=Doses(j);\n      GroupStore(rep,j)=Groups(j);\n    }\n\n\n\n  }\n\n\n\n}\n\n\n\n\n  List z1 = List::create(OptimalDoses,NTOX,TrialTimes,DoseStore,GroupStore);\n\n\n\n\n\n  return(z1);\n\n\n\n\n}\n\n\n\n\n\n\n//[[Rcpp::export]]\narma::vec GetDose1( arma::vec Y, //Vector of Times\n                    arma::vec I, //Vector of Toxicity Indicators\n                    arma::vec Doses, //Standardized Dose Values given to each patient\n                    arma::vec Groups, //SubGroup Membership\n                    arma::mat DoseTried, //Matrix of Tried doses for each simulation\n                    double T1, //Reference Time\n                    arma::vec Target, //Target Toxicity Probability\n                    arma::vec Upper, //Vector of Upper Cutoffs\n                    arma::vec Dose, //Standardized values of Doses considered\n                    double meanmu, //This is the prior mean of the baseline int\n                    double meanslope, //Prior mean of baseline slope\n                    arma::vec MeanInts, //Prior Means of Intercept Parameters\n                    arma::vec MeanSlopes, //Prior Means of Slope Parameters\n                    double varint, //Prior Variance of Intercept Parameters\n                    double varbeta //Prior Variance of Slope Parameters\n){\n\n\n  int g=0;\n\n  int StoreInx=0;\n\n  //Change this to be an input\n  arma::vec PROBIN(MeanInts.n_rows);\n  for(g=0;g<PROBIN.n_rows;g++){\n    PROBIN(g)=.9;\n  }\n\n  int MEANS=0;\n\n  int IntIN=0;\n  int IntOUT=0;\n\n  //Group Slope Prior Var\n  double varbeta1=varbeta;\n  //Group Int Prior Var\n  double varint1=varint;\n\n\n\n  int Group=0;\n  //Important For loop integer\n  int m =0; //For the inner MCMC looprep\n  int i=0; //For the patient index\n  int rep=0; //For the simulation repetition.\n\n\n  //First Fill out Target Vector\n  int nDose=Dose.n_rows;\n\n\n  //Important Integer Quantities\n  int B=2000; //Number of iterations for MCMC\n\n\n  int B1=B/2;\n\n  //Make List objects we'll use\n\n\n\n\n\n  //Innitialize parameters for MCMC\n  double mu=meanmu;\n  double slope=meanslope;\n  double sig=T1;\n\n  double NewMean=0;\n  double NewSlope=0;\n  int Which1=0;\n\n\n\n  //Important quantities we will need in the MCMC\n  int  J=MeanInts.n_rows;\n  double alpha=0;\n  double U=0;\n  double signew=0;\n  double slopenew=0;\n  double Munew=0;\n\n  //For loop integers\n  int j=0;\n  int k=0;\n\n\n  //Vector Of group intercepts\n  arma::vec a(J);\n  //Vector of group slopes\n  arma::vec b=a;\n  //Vectors for Group MCMC\n\n\n\n  //Vectors for proposals\n  arma::vec aprop = a;\n  arma::vec bprop=b;\n\n\n\n\n\n  arma::vec NumA(J);\n  arma::vec NumB(J);\n  arma::vec IntA(J);\n  arma::vec IntB(J);\n\n  double NumMu = 2;\n  double NumSlope=2;\n  double IntMu=1;\n  double IntSlope=1;\n\n  arma::vec avar(J);\n  arma::vec bvar(J);\n\n\n  double muvar=1;\n  double slopevar=1;\n  double trialtime=0;\n  NumericVector z9(2);\n  NumericVector zprop(5);\n\n  double NumSig=2;\n  double IntSig=1;\n  double sigvar=1;\n\n  arma::vec etaG(J+1);\n  arma::mat DoseProb(B1,(J+1)*nDose);\n  arma::mat MeanDose(J+1,nDose);\n  arma::vec sigstore(B1);\n  arma::vec mustore(B1);\n  arma::vec slopestore(B1);\n  arma::mat astore(B1,J);\n  arma::mat bstore=astore;\n  double eta1=0;\n  double DEC=0;\n\n  arma::vec GroupMem(J);\n  arma::vec GroupMemProp=GroupMem;\n\n  arma::vec INVEC(J);\n  INVEC.zeros();\n\n  int eta2=0;\n\n  arma::mat MeanVec((J+1),nDose);\n  arma::vec NTox(J+1);\n  arma::vec OptDose(J+1);\n  arma::vec StoppedGroups(J+1);\n  arma::vec SuspendGroups(J+1);\n  arma::vec GLast(J+1);\n  arma::vec nTreated(J+1);\n  double stopped=0;\n\n  arma::vec GroupVec(nDose);\n  arma::vec TriedGroups(J+1);\n\n\n\n\n  arma::vec nTreated1(J+1);\n  nTreated1.zeros();\n\n\n\n  arma::vec INVECNEW=INVEC;\n  arma::vec Y2;\n  arma::vec I2;\n  arma::vec Groups2;\n  arma::vec Doses2;\n  arma::vec GetGroup=StoppedGroups;\n\n\n  if(MeanInts.n_rows==1){\n    //Two Subgroups\n\n\n\n\n\n\n\n    //Inner MCMC loop, only compute neccessary quantities. Reset counters\n    NumA=NumA.zeros()+2;\n    NumB=NumB.zeros()+2;\n    IntA=IntA.zeros()+1;\n    IntB = IntB.zeros()+1;\n    NumMu = 2;\n    NumSlope=2;\n    IntMu=1;\n    IntSlope=1;\n    avar=avar.zeros()+1;\n    bvar=bvar.zeros()+1;\n    muvar=1;\n    slopevar=1;\n    NumSig=2;\n    IntSig=1;\n    sigvar=1;\n    a.zeros();\n    b.zeros();\n    MeanVec.zeros();\n    GroupVec.zeros();\n    mu=meanmu;\n    slope=meanslope;\n    INVEC.zeros();\n    INVEC = INVEC+1;\n    a=MeanInts;\n    b=MeanSlopes;\n\n    for(m=0;m<B;m++){\n\n      if(m<(B/2 + 2)){\n        if(m%100==0){\n\n\n          for(k=0;k<(J+1);k++){\n            if((IntA[k]/NumA[k])>.5){\n              avar[k]=avar[k]*2;\n            }\n\n            if((IntA[k]/NumA[k])<.2){\n              avar[k]=avar[k]/2;\n            }\n\n\n\n\n\n\n\n\n            if((IntB[k]/NumB[k])>.5){\n              bvar[k]=bvar[k]*2;\n            }\n\n            if((IntB[k]/NumB[k])<.2){\n              bvar[k]=bvar[k]/2;\n            }\n\n\n\n          }\n\n\n          if((IntMu/NumMu)>.5){\n            muvar=muvar*2;\n          }\n\n          if((IntMu/NumMu)<.2){\n            muvar=muvar/2;\n          }\n\n\n          if((IntSlope/NumSlope)>.5){\n            slopevar=slopevar*2;\n          }\n\n          if((IntSlope/NumSlope)<.2){\n            slopevar=slopevar/2;\n          }\n\n\n\n\n\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB=IntB.zeros()+1;\n\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          IntSig=1;\n          NumSig=2;\n\n\n\n\n        }\n      }\n\n\n\n      for(k=0;k<aprop.n_rows;k++){\n\n        if(INVEC[k]>0){\n\n          aprop=a;\n          aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n          alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n          if(U<alpha){\n            a(k)=aprop(k);\n            IntA[k]=IntA[k]+1;\n          }\n\n          NumA=NumA+1;\n\n\n        }\n      }\n      //Now do a MH step for the slope\n\n      for(k=0;k<aprop.size();k++){\n\n        if(INVEC[k]>0){\n          bprop=b;\n          bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n          alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  Like1(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n          z9[0]=alpha;\n\n          //  Rf_PrintValue(wrap(z9));\n\n          if(U<alpha){\n            b[k]=bprop[k];\n            IntB[k]=IntB[k]+1;\n          }\n\n        }\n\n      }\n\n\n      NumB=NumB+1;\n\n\n\n      //Spike And Slab\n\n      for(k=0;k<J;k++){\n        if(INVEC[k]==0){\n          //ADD Move\n          aprop[k]=as_scalar(arma::randn(1))/10;\n          bprop[k]=as_scalar(arma::randn(1))/10;\n\n\n          //Density when 0 is automatically 1 so no proposal needed\n          alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n          alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n          U=log(as_scalar(arma::randu(1)));\n\n          z9[0]=alpha;\n\n          //  Rf_PrintValue(wrap(z9));\n\n          if(U<alpha){\n            b[k]=bprop[k];\n            a[k]=aprop[k];\n            INVEC[k]=1;\n          }\n\n\n        }else{\n          //Delete Move\n\n          //Delete Move\n          aprop[k]=0;\n          bprop[k]=0;\n\n\n          //Density when 0 is automatically 1 so no proposal needed\n          alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  Like1(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n          alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n\n          if(U<alpha){\n            b[k]=0;\n            a[k]=0;\n          }\n\n\n        }\n\n\n\n\n\n\n\n      }\n\n\n\n\n\n\n\n      Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n      alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   Like1(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n      if(U<alpha){\n        mu=Munew;\n        IntMu=IntMu+1;\n      }\n\n      NumMu=NumMu+1;\n\n\n\n\n      //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n      slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n      //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n      //Proposal ratio for beta\n\n      alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n      alpha =   alpha+  Like1(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i) -  Like1(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i);\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n      if(U<alpha){\n        slope=slopenew;\n        IntSlope=IntSlope+1;\n      }\n      NumSlope=NumSlope+1;\n\n\n\n\n\n      if(m>(B-B1-1)){\n        //Make OptDose and StoppedGroups\n        StoreInx=m-B1;\n\n        for(j=0;j<J;j++){;\n          astore(StoreInx,j)=a(j);\n          bstore(StoreInx,j)=b[j];\n        }\n\n        mustore[StoreInx]=mu;\n        slopestore[StoreInx]=slope;\n        sigstore[StoreInx]=sig;\n\n\n        //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n        //First nDose\n\n\n        for(k=0;k<(J+1);k++){\n\n          for(j=0;j<nDose;j++){\n            eta1=0;\n\n            if(k>0){\n              eta1 = a[k-1]+exp(b[k-1]+slope)*Dose[j]+mu;\n            }\n\n            if(k==0){\n              eta1=mu+exp(slope)*Dose[j];\n\n            }\n\n            //For all groups add the intercept and slope*Groups\n\n            eta1=exp(eta1);\n\n            if(eta1>100000){\n              DoseProb(StoreInx, k*nDose+j) = 1;\n\n            }else{\n              DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n            }\n\n\n\n          }\n\n\n        }\n        //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n      }\n\n      //End MCMC\n    }\n\n\n\n    //Get Optimal Dose\n\n\n    StoppedGroups.zeros();\n    //Get MeanVec\n    //reset to means\n\n\n\n\n    //Now we have the mean vector\n\n\n\n    //Do we have a stopped group?\n    for(k=0;k<(J+1);k++){\n      eta2=0;\n\n      for(j=0;j<DoseProb.n_rows;j++){\n        //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n        if(DoseProb(j,k*nDose)>Target[k]){\n          eta2++;\n        }\n\n\n      }\n\n\n\n\n\n\n\n      if(eta2>(Upper[k]*DoseProb.n_rows)){\n        StoppedGroups[k]=1;\n      }\n\n    }\n\n\n\n\n\n\n    if(sum(StoppedGroups)>0){\n      //If we have a Stopped Group, Double Check that 3 patients have been fully evaluated\n\n      Y2=ReturnStoppedY(Y,I,Groups,StoppedGroups,i);\n      I2=ReturnStoppedI(Y,I,Groups,StoppedGroups,i);\n      Groups2=ReturnStoppedGroups(Y,I,Groups,StoppedGroups,i);\n      Doses2=ReturnStoppedY(Doses,I,Groups,StoppedGroups,i);\n\n\n\n\n\n\n\n\n\n      //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n\n      for(k=0;k<(J+1);k++){\n        if(nTreated1[k]<3){\n          StoppedGroups[k]=0;\n        }\n\n        if(nTreated1[k]>2){\n          GetGroup.zeros();\n          GetGroup[k]=1;\n\n          Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n          I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n          Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n          if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n            StoppedGroups[k]=0;\n          }\n\n        }\n\n\n      }\n\n\n\n\n      //If all groups are stopped, let's do separate trials JUST TO MAKE SURE ONE GROUP IS NOT DOMINATING THE DECISION TO STOP!!\n\n\n      //    Rf_PrintValue(wrap(StoppedGroups));\n      if(sum(StoppedGroups)==(J+1)){\n        //Let's try the groups separately to make sure we aren't stopping unneccessarily\n        StoppedGroups.zeros();\n\n        for(g=0;g<(J+1);g++){\n          GetGroup.zeros();\n          GetGroup[g]=1;\n\n          Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n          I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n          Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n          Which1 = g;\n\n\n          if(Which1==0){\n            NewMean = meanmu;\n            NewSlope=meanslope;\n          }else{\n            NewMean = meanmu+MeanInts[Which1-1];\n            NewSlope=meanslope+MeanSlopes[Which1-1];\n          }\n\n\n\n\n\n          //Inner MCMC loop, only compute neccessary quantities. Reset counters\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB = IntB.zeros()+1;\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          avar=avar.zeros()+1;\n          bvar=bvar.zeros()+1;\n          muvar=1;\n          slopevar=1;\n          NumSig=2;\n          IntSig=1;\n          sigvar=1;\n          a.zeros();\n          b.zeros();\n          MeanVec.zeros();\n          GroupVec.zeros();\n          mu=NewMean;\n          slope=NewSlope;\n\n\n          for(m=0;m<B;m++){\n\n            if(m<(B/2 + 2)){\n              if(m%100==0){\n\n\n\n\n                if((IntMu/NumMu)>.5){\n                  muvar=muvar*2;\n                }\n\n                if((IntMu/NumMu)<.2){\n                  muvar=muvar/2;\n                }\n\n\n                if((IntSlope/NumSlope)>.5){\n                  slopevar=slopevar*2;\n                }\n\n                if((IntSlope/NumSlope)<.2){\n                  slopevar=slopevar/2;\n                }\n\n\n\n\n\n\n\n                NumMu = 2;\n                NumSlope=2;\n                IntMu=1;\n                IntSlope=1;\n                IntSig=1;\n                NumSig=2;\n\n\n\n\n              }\n            }\n\n\n\n\n\n\n\n\n\n            Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n            alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              mu=Munew;\n              IntMu=IntMu+1;\n            }\n\n            NumMu=NumMu+1;\n\n\n\n\n            //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n            slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n            //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n            //Proposal ratio for beta\n\n            alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n            alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            U=log(as_scalar(arma::randu(1)));\n\n            if(U<alpha){\n              slope=slopenew;\n              IntSlope=IntSlope+1;\n            }\n            NumSlope=NumSlope+1;\n\n\n\n\n\n            if(m>(B-B1-1)){\n              //Make OptDose and StoppedGroups\n              StoreInx=m-B1;\n\n\n\n              //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n              //First nDose\n\n\n              k=Which1;\n\n              for(j=0;j<nDose;j++){\n                eta1=0;\n\n\n\n\n                eta1=mu+exp(slope)*Dose[j];\n\n\n\n                //For all groups add the intercept and slope*Groups\n\n                eta1=exp(eta1);\n\n                if(eta1>100000){\n                  DoseProb(StoreInx, k*nDose+j) = 1;\n\n                }else{\n                  DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n                }\n\n\n\n              }\n\n\n\n              //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n            }\n\n            //End MCMC\n          }\n          //Is our very last group stopped?\n\n          k=Which1;\n          eta2=0;\n\n          for(j=0;j<DoseProb.n_rows;j++){\n            //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n            if(DoseProb(j,k*nDose)>Target[k]){\n              eta2++;\n            }\n\n\n          }\n\n\n          if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n            StoppedGroups[Which1]=1;\n          }\n\n\n\n\n\n\n        }\n\n\n\n\n\n      }\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n    if(MEANS==0){\n      for(k=0;k<(J+1);k++){\n        for(j=0;j<nDose;j++){\n          MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n        }\n\n      }\n\n\n\n    }\n\n\n\n\n    //Determine Optimal Doses\n    for(k=0;k<(J+1);k++){\n\n      if(StoppedGroups(k)==1){\n        OptDose(k)=-1;\n      }else{\n        eta1=MinVec(abs(MeanVec.row(k).t()-Target[k]));\n        j=0;\n\n        GroupVec = abs(MeanVec.row(k).t()-Target[k]);\n\n        //  Rf_PrintValue(wrap(MeanVec));\n\n\n        while(GroupVec[j]!=eta1 ){\n          j++;\n          //Loop Proceeds until the minimum difference is reached\n        }\n\n        OptDose[k]=j;\n      }\n\n\n    }\n\n\n\n\n    //Is this dose bigger than the dose higher than what's been tried?\n    for(k=0;k<(J+1);k++){\n      if(StoppedGroups[k]==0){\n        for(j=0;j<(J+1);j++){\n          if(OptDose[j]>=nDose){\n            OptDose[j]=nDose-1;\n          }\n        }\n\n\n\n\n      }\n\n\n\n    }\n\n    //Is this dose bigger than the dose higher than what's been tried?\n    for(k=0;k<(J+1);k++){\n      if(StoppedGroups(k)==0){\n        if(DoseTried(k,OptDose[k])==0){\n          j=0;\n\n          while(DoseTried(k,j)==1){\n            j++;\n          }\n\n          OptDose[k]=j;\n\n        }\n      }\n    }\n\n\n\n\n\n\n\n    OptDose=OptDose+1;\n\n\n\n\n\n  }else{\n    //More than Two Subgroups\n\n\n\n\n    arma::mat MeanVec((J+1),nDose);\n    arma::vec NTox(J+1);\n    arma::vec OptDose(J+1);\n    arma::vec StoppedGroups(J+1);\n    arma::vec SuspendGroups(J+1);\n    arma::vec GLast(J+1);\n    arma::vec nTreated(J+1);\n     stopped=0;\n    arma::vec GroupVec(nDose);\n    arma::vec TriedGroups(J+1);\n\n\n\n\n    arma::mat DoseTried((J+1),nDose);\n    arma::vec nTreated1(J+1);\n    nTreated1.zeros();\n    INVEC.zeros();\n\n    arma::vec INVECNEW=INVEC;\n    arma::vec Y2;\n    arma::vec I2;\n    arma::vec Groups2;\n    arma::vec Doses2;\n    arma::vec GetGroup=StoppedGroups;\n\n\n\n\n\n\n\n\n\n\n\n\n    //Inner MCMC loop, only compute neccessary quantities. Reset counters\n    NumA=NumA.zeros()+2;\n    NumB=NumB.zeros()+2;\n    IntA=IntA.zeros()+1;\n    IntB = IntB.zeros()+1;\n    NumMu = 2;\n    NumSlope=2;\n    IntMu=1;\n    IntSlope=1;\n    avar=avar.zeros()+1;\n    bvar=bvar.zeros()+1;\n    muvar=1;\n    slopevar=1;\n    NumSig=2;\n    IntSig=1;\n    sigvar=1;\n    a.zeros();\n    b.zeros();\n    MeanVec.zeros();\n    GroupVec.zeros();\n    mu=meanmu;\n    slope=meanslope;\n    INVEC.zeros();\n    INVECNEW.zeros();\n    INVEC = INVEC+1;\n    a=MeanInts;\n    b=MeanSlopes;\n\n\n    for(m=0;m<GroupMem.n_rows;m++){\n      GroupMem[m]=m+1;\n    }\n\n    GroupMemProp=GroupMem;\n\n\n    for(m=0;m<B;m++){\n\n      if(m<(B/2 + 2)){\n        if(m%100==0){\n\n\n          for(k=0;k<(J+1);k++){\n            if((IntA[k]/NumA[k])>.5){\n              avar[k]=avar[k]*2;\n            }\n\n            if((IntA[k]/NumA[k])<.2){\n              avar[k]=avar[k]/2;\n            }\n\n\n\n\n\n\n\n\n            if((IntB[k]/NumB[k])>.5){\n              bvar[k]=bvar[k]*2;\n            }\n\n            if((IntB[k]/NumB[k])<.2){\n              bvar[k]=bvar[k]/2;\n            }\n\n\n\n          }\n\n\n          if((IntMu/NumMu)>.5){\n            muvar=muvar*2;\n          }\n\n          if((IntMu/NumMu)<.2){\n            muvar=muvar/2;\n          }\n\n\n          if((IntSlope/NumSlope)>.5){\n            slopevar=slopevar*2;\n          }\n\n          if((IntSlope/NumSlope)<.2){\n            slopevar=slopevar/2;\n          }\n\n\n\n\n\n          NumA=NumA.zeros()+2;\n          NumB=NumB.zeros()+2;\n          IntA=IntA.zeros()+1;\n          IntB=IntB.zeros()+1;\n\n          NumMu = 2;\n          NumSlope=2;\n          IntMu=1;\n          IntSlope=1;\n          IntSig=1;\n          NumSig=2;\n\n\n\n\n        }\n      }\n\n\n\n      for(k=0;k<aprop.n_rows;k++){\n\n        if(INVEC[k]>0){\n\n          aprop=a;\n          aprop(k)=as_scalar(arma::randn(1))*avar[k] + a(k);\n\n\n\n\n\n\n          alpha =    .5*pow((a[k]-MeanInts[k]),2)/varint1 -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n          if(U<alpha){\n            a(k)=aprop(k);\n            IntA[k]=IntA[k]+1;\n          }\n\n          NumA=NumA+1;\n\n\n        }\n      }\n      //Now do a MH step for the slope\n\n      for(k=0;k<aprop.size();k++){\n\n        if(INVEC[k]>0){\n          bprop=b;\n          bprop[k] = b[k] +   as_scalar(arma::randn(1))*bvar[k];\n\n\n\n          alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((b[k]-MeanSlopes[k]),2)/varbeta1  +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, bprop, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n          z9[0]=alpha;\n\n          //  Rf_PrintValue(wrap(z9));\n\n          if(U<alpha){\n            b[k]=bprop[k];\n            IntB[k]=IntB[k]+1;\n          }\n\n        }\n\n      }\n\n\n      NumB=NumB+1;\n\n\n\n      //Spike And Slab\n\n\n      U=as_scalar(arma::randu(1));\n\n\n      if((3*U)<1){\n        //Add All or delete all\n\n        if(sum(INVEC)==(J)){\n          //Auto Delete Move\n\n\n\n\n          aprop.zeros();\n          bprop.zeros();\n\n          GroupMemProp=GroupMem;\n          //Now Randomly Draw Our New Group Assignment\n\n\n          INVECNEW.zeros();\n\n\n\n\n          GroupMemProp.zeros();\n\n\n\n\n          alpha=0;\n          for(k=0;k<bprop.n_rows;k++){\n            alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n          }\n\n\n\n\n\n          //Density when 0 is automatically 1 so no proposal needed\n          alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n\n          if(U<alpha){\n            b.zeros();\n            a.zeros();\n            GroupMem.zeros();\n            INVEC.zeros();\n\n            //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n          }\n\n\n\n\n\n\n        }else{\n\n\n          if(sum(INVEC)==0){\n            //Autho Add Move\n\n            //ADD Move\n\n            for(k=0;k<aprop.n_rows;k++){\n              aprop[k]=as_scalar(arma::randn(1));\n              bprop[k]=as_scalar(arma::randn(1))/10;\n              GroupMemProp[k]=k+1;\n            }\n\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n\n            alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n            for(k=0;k<aprop.n_rows;k++){\n\n\n              alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n            }\n\n\n\n\n            alpha=alpha + log(sum(INVEC)+1);\n\n            U=log(as_scalar(arma::randu(1)));\n\n            z9[0]=alpha;\n\n            //  Rf_PrintValue(wrap(z9));\n\n            if(U<alpha){\n\n              for(k=0;k<aprop.n_rows;k++){\n                b[k]=bprop[k];\n                a[k]=aprop[k];\n                INVEC[k]=1;\n                GroupMem[k]=k+1;\n              }\n\n\n            }\n\n\n\n\n          }else{\n            //Randomly Decide to add or Delete\n\n            U=as_scalar(arma::randu(1));\n\n\n            if(U<.5){\n              //Add\n\n\n              //ADD Move\n\n              for(k=0;k<aprop.n_rows;k++){\n                aprop[k]=as_scalar(arma::randn(1));\n                bprop[k]=as_scalar(arma::randn(1))/10;\n                GroupMemProp[k]=k+1;\n              }\n\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n\n              alpha =  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n              for(k=0;k<aprop.n_rows;k++){\n\n\n                alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]) -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 ;\n\n              }\n\n\n\n\n              alpha=alpha + log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n              z9[0]=alpha;\n\n              //  Rf_PrintValue(wrap(z9));\n\n              if(U<alpha){\n\n                for(k=0;k<aprop.n_rows;k++){\n                  b[k]=bprop[k];\n                  a[k]=aprop[k];\n                  INVEC[k]=1;\n                  GroupMem[k]=k+1;\n                }\n\n\n              }\n\n\n\n            }else{\n              //Delete All\n\n\n\n\n              aprop.zeros();\n              bprop.zeros();\n\n              GroupMemProp=GroupMem;\n              //Now Randomly Draw Our New Group Assignment\n\n\n              INVECNEW.zeros();\n\n\n\n\n              GroupMemProp.zeros();\n\n\n\n\n              alpha=0;\n              for(k=0;k<bprop.n_rows;k++){\n                alpha=alpha +  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n              }\n\n\n\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n              alpha =  alpha + LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n              U=log(as_scalar(arma::randu(1)));\n\n\n\n              if(U<alpha){\n                b.zeros();\n                a.zeros();\n                GroupMem.zeros();\n                INVEC.zeros();\n\n                //If Any other GroupMEM are in this group, we need to delete them.\n\n\n\n              }\n\n\n\n\n            }\n\n\n\n\n\n          }\n\n\n\n\n        }\n\n\n\n\n\n\n\n\n\n      }else{\n\n\n\n        //Should we swap?\n        if((sum(INVEC)==J) || (sum(INVEC)==0)){\n          //Add/Delete\n\n\n\n          k=Sample1(J);\n\n          if(INVEC[k]==0){\n            //ADD Move\n            aprop=a;\n            bprop=b;\n            aprop[k]=as_scalar(arma::randn(1));\n            bprop[k]=as_scalar(arma::randn(1))/10;\n\n            GroupMemProp=GroupMem;\n            GroupMemProp[k]=k+1;\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n            alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n            alpha=alpha + log(sum(INVEC)+1);\n\n            U=log(as_scalar(arma::randu(1)));\n\n            z9[0]=alpha;\n\n            //  Rf_PrintValue(wrap(z9));\n\n            if(U<alpha){\n              b[k]=bprop[k];\n              a[k]=aprop[k];\n              INVEC[k]=1;\n              GroupMem[k]=k+1;\n            }\n\n\n          }else{\n            //Delete Move\n            aprop=a;\n            bprop=b;\n            //Delete Move\n            aprop[k]=0;\n            bprop[k]=0;\n\n            GroupMemProp=GroupMem;\n            //Now Randomly Draw Our New Group Assignment\n\n\n            INVECNEW=INVEC;\n            INVECNEW[k]=0;\n\n\n\n            GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n            //Density when 0 is automatically 1 so no proposal needed\n            alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n            alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n            alpha=alpha-log(sum(INVEC)+1);\n\n            U=log(as_scalar(arma::randu(1)));\n\n\n\n            if(U<alpha){\n              b[k]=0;\n              a[k]=0;\n              GroupMem=GroupMemProp;\n              INVEC[k]=0;\n\n              //If Any other GroupMEM are in this group, we need to delete them.\n\n              for(j=0;j<GroupMem.n_rows;j++){\n                if(GroupMem[j]==(k+1)){\n                  GroupMem[j]=GroupMem[k];\n                }\n              }\n\n\n\n            }\n\n\n          }\n\n\n        }else{\n\n\n\n\n          if((3*U)>2){\n            //Swap Move\n            //Randomly Pick One In and One Out\n\n            IntIN = GetIn(INVEC);\n            IntOUT= GetOut(INVEC);\n\n            //Now IntIN and IntOUT contain the entries that are currently in or out\n\n\n\n\n\n          }else{\n            //Add/Delete\n\n\n\n            k=Sample1(J);\n\n            if(INVEC[k]==0){\n              //ADD Move\n              aprop=a;\n              bprop=b;\n              aprop[k]=as_scalar(arma::randn(1));\n              bprop[k]=as_scalar(arma::randn(1))/10;\n\n              GroupMemProp=GroupMem;\n              GroupMemProp[k]=k+1;\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n              alpha =  -.5*pow((bprop[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n              alpha = alpha -.5*pow((aprop[k]-MeanInts[k]),2)/varint1 + log(PROBIN[k])-log(1-PROBIN[k]);\n\n\n              alpha=alpha + log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n              z9[0]=alpha;\n\n              //  Rf_PrintValue(wrap(z9));\n\n              if(U<alpha){\n                b[k]=bprop[k];\n                a[k]=aprop[k];\n                INVEC[k]=1;\n                GroupMem[k]=k+1;\n              }\n\n\n            }else{\n              //Delete Move\n              aprop=a;\n              bprop=b;\n              //Delete Move\n              aprop[k]=0;\n              bprop[k]=0;\n\n              GroupMemProp=GroupMem;\n              //Now Randomly Draw Our New Group Assignment\n\n\n              INVECNEW=INVEC;\n              INVECNEW[k]=0;\n\n\n\n              GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n              //Density when 0 is automatically 1 so no proposal needed\n              alpha =  .5*pow((b[k]-MeanSlopes[k]),2)/varbeta1 +  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, aprop, bprop, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n              alpha = alpha +.5*pow((a[k]-MeanInts[k]),2)/varint1 + log(1-PROBIN[k])-log(PROBIN[k]);\n\n              alpha=alpha-log(sum(INVEC)+1);\n\n              U=log(as_scalar(arma::randu(1)));\n\n\n\n              if(U<alpha){\n                b[k]=0;\n                a[k]=0;\n                GroupMem=GroupMemProp;\n                INVEC[k]=0;\n\n                //If Any other GroupMEM are in this group, we need to delete them.\n\n                for(j=0;j<GroupMem.n_rows;j++){\n                  if(GroupMem[j]==(k+1)){\n                    GroupMem[j]=GroupMem[k];\n                  }\n                }\n\n\n\n              }\n\n\n            }\n\n\n          }\n\n\n\n        }\n\n      }\n\n\n\n\n\n\n      //Swap Group\n\n      for(k=0;k<J;k++){\n        if(INVEC[k]==0){\n\n          GroupMemProp=GroupMem;\n          //Now Randomly Draw Our New Group Assignment\n\n\n          INVECNEW=INVEC;\n          INVECNEW[k]=0;\n\n\n\n          GroupMemProp[k]=GetNewGroup(INVECNEW);\n\n\n\n\n\n\n\n\n\n\n          //Density when 0 is automatically 1 so no proposal needed\n          alpha = LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMemProp) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n\n          if(U<alpha){\n            GroupMem[k]=GroupMemProp[k];\n          }\n        }\n\n      }\n\n\n\n\n\n\n      Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n      alpha= .5*pow((mu-meanmu),2)/varint -.5*pow((Munew-meanmu),2)/varint+   LikeMULTI(Y, I,  Doses, Groups,  Munew,slope, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n      if(U<alpha){\n        mu=Munew;\n        IntMu=IntMu+1;\n      }\n\n      NumMu=NumMu+1;\n\n\n\n\n      //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n      slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n      //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n      //Proposal ratio for beta\n\n      alpha =.5*pow((slope-meanslope),2)/varbeta -.5*pow((slopenew-meanslope),2)/varbeta;\n\n\n      alpha =   alpha+  LikeMULTI(Y, I,  Doses, Groups,  mu,slopenew, a, b, sig,i,GroupMem) -  LikeMULTI(Y, I,  Doses, Groups,  mu,slope, a, b, sig,i,GroupMem);\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n\n\n      U=log(as_scalar(arma::randu(1)));\n\n      if(U<alpha){\n        slope=slopenew;\n        IntSlope=IntSlope+1;\n      }\n      NumSlope=NumSlope+1;\n\n\n      if(m>(B-B1-1)){\n        //Make OptDose and StoppedGroups\n        StoreInx=m-B1;\n\n        for(j=0;j<J;j++){;\n          astore(StoreInx,j)=INVEC(j);\n          bstore(StoreInx,j)=GroupMem[j];\n        }\n\n        mustore[StoreInx]=mu;\n        slopestore[StoreInx]=slope;\n        sigstore[StoreInx]=sig;\n\n\n        //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n        //First nDose\n\n        aprop.zeros();\n        bprop.zeros();\n        for(j=0;j<J;j++){\n          for(k=0;k<J;k++){\n            if(GroupMem[j]==(k+1)){\n              aprop[j]=a[k];\n              bprop[j]=b[k];\n            }\n          }\n        }\n\n\n        for(k=0;k<(J+1);k++){\n\n          for(j=0;j<nDose;j++){\n            eta1=0;\n\n            if(k>0){\n              eta1 = aprop[k-1]+exp(bprop[k-1]+slope)*Dose[j]+mu;\n            }\n\n            if(k==0){\n              eta1=mu+exp(slope)*Dose[j];\n\n            }\n\n            //For all groups add the intercept and slope*Groups\n\n            eta1=exp(eta1);\n\n            if(eta1>100000){\n              DoseProb(StoreInx, k*nDose+j) = 1;\n\n            }else{\n              DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n            }\n\n\n\n          }\n\n\n        }\n        //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n      }\n\n      //End MCMC\n\n\n\n\n\n\n    }\n\n\n    StoppedGroups.zeros();\n    //Get MeanVec\n    //reset to means\n\n\n\n\n    //Now we have the mean vector\n\n\n\n    //Do we have a stopped group?\n    for(k=0;k<(J+1);k++){\n      eta2=0;\n\n      for(j=0;j<DoseProb.n_rows;j++){\n        //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n        if(DoseProb(j,k*nDose)>Target[k]){\n          eta2++;\n        }\n\n\n      }\n\n\n\n\n\n\n\n      if(eta2>(Upper[k]*DoseProb.n_rows)){\n        StoppedGroups[k]=1;\n      }\n\n    }\n\n\n\n\n\n\n\n\n\n    //If we don't have at least 3 patients enrolled at the lowest dose, let's drop the Stopped Group\n    for(k=0;k<(J+1);k++){\n      if(nTreated1[k]<3){\n        StoppedGroups[k]=0;\n      }\n\n      if(nTreated1[k]>2){\n        GetGroup.zeros();\n        GetGroup[k]=1;\n\n        Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n        I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n        Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n        if(GetFullyFollowed(Y2,I2,Doses2,Dose,T1)<3){\n          StoppedGroups[k]=0;\n        }\n\n      }\n\n\n    }\n\n\n\n\n    //If all groups are stopped, let's do separate trials JUST TO MAKE SURE ONE GROUP IS NOT DOMINATING THE DECISION TO STOP!!\n\n\n    //    Rf_PrintValue(wrap(StoppedGroups));\n    if(sum(StoppedGroups)==(J+1)){\n      //Let's try the groups separately to make sure we aren't stopping unneccessarily\n      StoppedGroups.zeros();\n\n      for(g=0;g<(J+1);g++){\n        GetGroup.zeros();\n        GetGroup[g]=1;\n\n        Y2=ReturnStoppedY(Y,I,Groups,GetGroup,i);\n        I2=ReturnStoppedI(Y,I,Groups,GetGroup,i);\n        Doses2=ReturnStoppedY(Doses,I,Groups,GetGroup,i);\n\n\n\n        Which1 = g;\n\n\n        if(Which1==0){\n          NewMean = meanmu;\n          NewSlope=meanslope;\n        }else{\n          NewMean = meanmu+MeanInts[Which1-1];\n          NewSlope=meanslope+MeanSlopes[Which1-1];\n        }\n\n\n\n\n\n        //Inner MCMC loop, only compute neccessary quantities. Reset counters\n        NumA=NumA.zeros()+2;\n        NumB=NumB.zeros()+2;\n        IntA=IntA.zeros()+1;\n        IntB = IntB.zeros()+1;\n        NumMu = 2;\n        NumSlope=2;\n        IntMu=1;\n        IntSlope=1;\n        avar=avar.zeros()+1;\n        bvar=bvar.zeros()+1;\n        muvar=1;\n        slopevar=1;\n        NumSig=2;\n        IntSig=1;\n        sigvar=1;\n        a.zeros();\n        b.zeros();\n        MeanVec.zeros();\n        GroupVec.zeros();\n        mu=NewMean;\n        slope=NewSlope;\n\n\n        for(m=0;m<B;m++){\n\n          if(m<(B/2 + 2)){\n            if(m%100==0){\n\n\n\n\n              if((IntMu/NumMu)>.5){\n                muvar=muvar*2;\n              }\n\n              if((IntMu/NumMu)<.2){\n                muvar=muvar/2;\n              }\n\n\n              if((IntSlope/NumSlope)>.5){\n                slopevar=slopevar*2;\n              }\n\n              if((IntSlope/NumSlope)<.2){\n                slopevar=slopevar/2;\n              }\n\n\n\n\n\n\n\n              NumMu = 2;\n              NumSlope=2;\n              IntMu=1;\n              IntSlope=1;\n              IntSig=1;\n              NumSig=2;\n\n\n\n\n            }\n          }\n\n\n\n\n\n\n\n\n\n          Munew = mu + as_scalar(arma::randn(1))*muvar;\n\n\n\n          alpha= .5*pow((mu-NewMean),2)/varint -.5*pow((Munew-NewMean),2)/varint+   Like2(Y2, I2,  Doses2,  Munew,slope, sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope,  sig,Y2.n_rows);\n\n\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n          if(U<alpha){\n            mu=Munew;\n            IntMu=IntMu+1;\n          }\n\n          NumMu=NumMu+1;\n\n\n\n\n          //Sample the new slope and the new \\beta_g coefficients jointly\n\n\n\n\n          slopenew = slope + as_scalar(arma::randn(1))*slopevar;\n\n\n\n          //        slopenew = slopevar +   as_scalar(arma::randn(1))*slopevar;\n\n\n          //Proposal ratio for beta\n\n          alpha =.5*pow((slope-NewSlope),2)/varbeta -.5*pow((slopenew-NewSlope),2)/varbeta;\n\n\n          alpha =   alpha+  Like2(Y2, I2,  Doses2,   mu,slopenew,sig,Y2.n_rows) -  Like2(Y2, I2,  Doses2,   mu,slope, sig,Y2.n_rows);\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n\n\n          U=log(as_scalar(arma::randu(1)));\n\n          if(U<alpha){\n            slope=slopenew;\n            IntSlope=IntSlope+1;\n          }\n          NumSlope=NumSlope+1;\n\n\n\n\n\n          if(m>(B-B1-1)){\n            //Make OptDose and StoppedGroups\n            StoreInx=m-B1;\n\n\n\n            //Fill in Big matrix of dose toxicity probabilities for each subgroup and dose\n            //First nDose\n\n\n            k=Which1;\n\n            for(j=0;j<nDose;j++){\n              eta1=0;\n\n\n\n\n              eta1=mu+exp(slope)*Dose[j];\n\n\n\n              //For all groups add the intercept and slope*Groups\n\n              eta1=exp(eta1);\n\n              if(eta1>100000){\n                DoseProb(StoreInx, k*nDose+j) = 1;\n\n              }else{\n                DoseProb(StoreInx, k*nDose+j) = eta1/(1+eta1);\n\n              }\n\n\n\n            }\n\n\n\n            //Now we have a matrix containing our sampled dose probabilities\n\n\n\n\n\n\n\n\n\n          }\n\n          //End MCMC\n        }\n        //Is our very last group stopped?\n\n        k=Which1;\n        eta2=0;\n\n        for(j=0;j<DoseProb.n_rows;j++){\n          //     eta2 = eta2 + DoseProb(j,k*nDose)>Target[k];\n          if(DoseProb(j,k*nDose)>Target[k]){\n            eta2++;\n          }\n\n\n        }\n\n\n        if(eta2>(Upper[Which1]*DoseProb.n_rows)){\n          StoppedGroups[Which1]=1;\n        }\n\n\n\n\n\n\n      }\n\n\n\n\n\n    }\n\n\n\n\n    if(MEANS==0){\n      for(k=0;k<(J+1);k++){\n        for(j=0;j<nDose;j++){\n          MeanVec(k,j)=sum(DoseProb.col(k*nDose+j))/DoseProb.n_rows;\n\n        }\n\n      }\n\n\n    }\n\n\n\n\n    //Determine Optimal Doses\n    for(k=0;k<(J+1);k++){\n\n      if(StoppedGroups(k)==1){\n        OptDose(k)=-1;\n      }else{\n        eta1=MinVec(abs(MeanVec.row(k).t()-Target[k]));\n        j=0;\n\n        GroupVec = abs(MeanVec.row(k).t()-Target[k]);\n\n        //  Rf_PrintValue(wrap(MeanVec));\n\n\n        while(GroupVec[j]!=eta1 ){\n          j++;\n          //Loop Proceeds until the minimum difference is reached\n        }\n\n        OptDose[k]=j;\n      }\n\n\n    }\n\n\n\n\n    //Is this dose bigger than the dose higher than what's been tried?\n    for(k=0;k<(J+1);k++){\n      if(StoppedGroups[k]==0){\n        for(j=0;j<(J+1);j++){\n          if(OptDose[j]>=nDose){\n            OptDose[j]=nDose-1;\n          }\n        }\n\n\n\n\n      }\n\n\n\n    }\n\n    //Is this dose bigger than the dose higher than what's been tried?\n    for(k=0;k<(J+1);k++){\n      if(StoppedGroups(k)==0){\n        if(DoseTried(k,OptDose[k])==0){\n          j=0;\n\n          while(DoseTried(k,j)==1){\n            j++;\n          }\n\n          OptDose[k]=j;\n\n        }\n      }\n    }\n\n\n\n\n\n\n\n\n\n\n    OptDose=OptDose+1;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  }\n\n\n\n\n\n  return(OptDose);\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1508355646820.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1135|21|3099|3|\n3146|19|3152|4|\n5903|31|6154|6|\n6191|36|6437|6|\n6459|27|6481|6|\n6505|27|6518|6|\n6773|25|7579|0|\n7659|21|8473|4|\n",
    "hash" : "978121989",
    "id" : "710D84AF",
    "lastKnownWriteTime" : 1509816775,
    "last_content_update" : 1509816775477,
    "path" : "D:/Users/Andrew/Desktop/Rice/Dr.Thall/SubTite/src/SUBGROUP.cpp",
    "project_path" : "src/SUBGROUP.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}